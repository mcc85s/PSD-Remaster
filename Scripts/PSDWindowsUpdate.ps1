#_____________________________________________________________________________________________________________________________________________________
#//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\--//--\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//  [ Secure Digits Plus LLC | Hybrid | Desired State Controller ]  \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯     __________________________________________________________     ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯ -=-=-=-=-=-=-=[ Dynamically Engineered Digital Security ]-=-=-=-=-=-=--=-= ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯                                           ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯    //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//   Application Development | Virtualization | Network and Hardware Magistration   \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//   https://www.securedigitsplus.com | Server-Client | Seedling-Spawning Script    \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\___¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ___//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   [ Provisional Author : Michael C Cook Sr. | "The Buck Stops Here" ]    //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//   ____    ____    ____    ____    ____    ____    ____    ____    ____   \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
#//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\
#\\  [ PSDWindowsUpdate ] @: Heavily Modified and restructured version of the PSDWindowsUpdate.ps1 file from FriendsOfMDT                    //  \\__//
#//__________________________________________________________________________________________________________________________________________\\__//¯¯\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
# ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯
#  [ 2019/09/21 @ MC ] Will be restructuring the remaining PSDScripts, but this one needed it. Originally 1500~ lines, it's now 700. Plenty more to do.
# ____    ____    ____    ____    ____    ____    ____    ____                                 ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯           ¯¯¯¯
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//
#//¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯   //¯¯\\
#\\                                                      \\__//
#// ____________  _____________________________          //¯¯\\
#\\ [ Modified ]  PowerShell Deployment for MDT          \\__//
#// ¯¯¯¯¯¯¯¯¯¯¯¯  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯          //¯¯\\
#//        File:  PSDWindowsUpdate.ps1                   \\__//
#\\        ¯¯¯¯¯  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                   //¯¯\\
#//     Purpose:  Apply the specified operating system.  \\__//
#\\     ¯¯¯¯¯¯¯¯  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯  //¯¯\\
#//                                                      \\__//
#\\___    ____    ____    ____    ____    ____    ____   //¯¯\\
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\  \\__//
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//__//¯¯\\
# ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯¯¯¯¯¯¯¯¯¯
    Using Namespace System.Security.Principal

    Param ( )

    Import-Module PSDUtility
    Import-Module PSDDeploymentShare

    If ( ( "Windows" | % { IEX "( [ $( $_ )Principal ][ $( $_ )Identity ]::GetCurrent() ).IsInRole( 'Administrator' )" } ) -eq $True ) { $Admin = 1 }

    $VerbosePreference = "Continue"
    Write-PSDLog -Message "$( $MyInvocation.MyCommand.Name ): Load core modules"
    Write-PSDLog -Message "$( $MyInvocation.MyCommand.Name ): Deployroot is now $deployRoot"
    Write-PSDLog -Message "$( $MyInvocation.MyCommand.Name ): env:PSModulePath is now $env:PSModulePath"

    $Script = @'
    Function Find-WindowsUpdateList 
    {
        Param ( [ Parameter ( Mandatory = $True ) ][ String ]  $SearchCriteria ,
                [ Parameter ( Mandatory = $True ) ][ String ]       $SessionId ,
                [ Parameter ( Mandatory = $true ) ][  Int16 ] $serverSelection )

        Function GenerateSearchHash( $searchResults )
        {
            ForEach ( $searchResult in $searchResults )
            {
                Foreach ( $KBArticleID in $searchResult.KBArticleIDs )
                {
                    $KBID = "KB$KBArticleID"
                    If ( $KBArticleID -ne $null -and -Not $SearchHash.ContainsKey( $KBID ) )
                    {
                        $searchHash.Add( $KBID, ( $searchResult | Microsoft.PowerShell.Utility\Select-Object MSRCSeverity , Title , IsMandatory ) )
                    }
                }
            }
        }

        Function GenerateHistoryHash( $HistoryResults )
        {
            ForEach ( $HistoryResult in $HistoryResults)
            {
                $KBID = ( [ Regex ]::match( $historyResult.Title , 'KB(\d+)' ) ).Value.ToUpper()

                If ( $KBID -ne $null -and $KBID -ne '' )
                {
                    $Title = $HistoryResult.Title.Trim()

                    If ( -Not $HistoryHash.ContainsKey( $KBID ) )
                    {
                        $HistoryHash.Add( $KBID , ( $HistoryResult | Microsoft.PowerShell.Utility\Select-Object  ResultCode, Date, Title ) )
                    } 
                
                    ElseIf ( ( $HistoryHash[ $KBID ].Title -eq $null -or $HistoryHash[ $KBID ].Title -eq '' ) -and ( $Title -ne $Null -or $Title.Length -gt 0 ) )
                    {
                        $HistoryHash[ $KBID ] = $historyResult | Microsoft.PowerShell.Utility\Select-Object  ResultCode , Date , $Title
                    }
                }
            }
        }

        $ObjSession                  = New-Object -ComObject "Microsoft.Update.Session"
        $ObjSearcher                 = $ObjSession.CreateUpdateSearcher()
        $ObjSearcher.ServerSelection = $ServerSelection
        $ObjResults                  = $ObjSearcher.Search( $SearchCriteria )

        $Result = New-Object Collections.ArrayList

        If ( $SearchCriteria -eq "IsInstalled=1" )
        {
            $SearchHash              = @{}

            GenerateSearchHash( $objResults.Updates )

            $HistoryCount            = $ObjSearcher.GetTotalHistoryCount()
            $HistoryResults          = $objSearcher.QueryHistory( 0 , $HistoryCount )

            $HistoryHash             = @{}

            GenerateHistoryHash( $HistoryResults )

            $InstalledItems          = Get-Hotfix

            ForEach ( $InstalledItem in $InstalledItems )
            {
                $ResultItem          = $InstalledItem | Microsoft.PowerShell.Utility\Select-Object HotFixID , InstalledBy
                $Title               = "$( $InstalledItem.Description ) ($( $resultItem.HotFixID ))"
                $InstallDate         = $InstalledItem.InstalledOn
                $TitleMatch          = $Null
                $SearchMatch         = $SearchHash.Item( $InstalledItem.HotFixID )

                If ( $SearchMatch -ne $null )
                {
                    $TitleMatch      = $SearchMatch.Title
                    $Names           = "msrcSeverity" , "IsMandatory"
                    $Values          =  $SearchMatch.MSRCSeverity , $SearchMatch.IsMandatory

                    0..1 | % { $ResultItem | Add-Member -MemberType NoteProperty -Name $Names[$_] -Value $Values[$_] }
                }

                $HistoryMatch        = $HistoryHash.Item( $InstalledItem.HotFixID )

                If ( $HistoryMatch -ne $null )
                {
                    $ResultItem | Add-Member -MemberType NoteProperty -Name "InstallState" -Value $HistoryMatch.ResultCode

                    If ( $TitleMatch -eq $Null -or $TitleMatch -eq '' ) { $TitleMatch = $HistoryMatch.title }

                    $InstallDate     = $HistoryMatch.Date
                }

                If ( $TitleMatch -ne $null -or $TitleMatch -ne '' ) { $Title = $TitleMatch }

                $Names               = "Title" , "InstallDate"
                $Values              = $Title  , $InstallDate
                
                0..1 | % { $ResultItem | Add-Member -MemberType NoteProperty -Name $Names[$_] -Value $Value[$_] }

                $Result.Add( $ResultItem )
            }
        }
     
        Else 
        {
            Foreach ( $ObjResult in $ObjResults.Updates ) 
            {
                $ResultItem          = $ObjResult | Microsoft.PowerShell.Utility\Select-Object MSRCSeverity , Title , IsMandatory
                $Result.Add( $ResultItem )
            }
        }

        If ( Test-Path $ResultFile ) { Remove-Item $ResultFile }

        $Result | ConvertTo-Json -depth 10 | Out-File $ResultFile
'@

        $TimeStamp                   = Get-Date -Format FileDateTimeUniversal
        $Fileprefix                  = "_PS$sessionId`_Time$timeStamp"
        $ResultFile                  = "$env:TEMP\Find-Updates-result$fileprefix.json"
        $Script                      = "`$searchCriteria = '$searchCriteria';'`$ResultFile = '$ResultFile';'`$serverSelection ='$serverSelection';$Script"
        $ScriptFile                  = "$env:TEMP\Find-Updates$fileprefix.ps1"

        $Script | Out-File $ScriptFile

        If ( ! ( Test-Path $ScriptFile ) )
        {
            $Message                 = "Failed to create file:$ScriptFile"

            Write-Error $message

            Return
        }

        $TaskName = "SMEWindowsUpdateFindUpdates$fileprefix"

        If ( $Admin -eq 1 ) { $Arg   = "-NoProfile -NoLogo -NonInteractive -ExecutionPolicy Bypass -File $ScriptFile" }
        Else { Write-Warning "To perform some operations you must run an elevated Windows PowerShell console." }

        $Scheduler = New-Object -ComObject Schedule.Service

        For ( $i = 1 ; $i -le 3 ; $i++ )
        {
	        Try
    	    {
	    	    $Scheduler.Connect()
		        Break
    	    }

	        Catch
    	    {
    		    If ( $i -ge 3 )
		        {
                    $EVLog = @{ LogName   =                       "Application"
                                Source    =  "SME Windows Updates Find Updates"
                                EntryType =                             "Error"
                                EventID   =                                  1
                                Message   = "Can't connect to Schedule service" }

		            Write-EventLog @EVLog

    			    Write-Error "Can't connect to Schedule service" -ErrorAction Stop
	    	    }

                Else 
                { 
                    Start-Sleep -S 1
                }
    	    }
        }

        $RootFolder = $Scheduler.GetFolder( "\" )

        If ( $RootFolder.GetTasks( 0 ) | ? { $_.Name -eq $TaskName } )
        {
	        Write-Debug( "Deleting existing task$TaskName" )
	        $RootFolder.DeleteTask( $TaskName , 0 )
        }

        $Task                         = $Scheduler.NewTask( 0 )
        $RegistrationInfo             = $Task.RegistrationInfo
        $RegistrationInfo             | % { $_.Description = $TaskName ; $_.Author = $User.Name }
        $Triggers                     = $Task.Triggers
        $Trigger                      = $Triggers.Create( 7 )
        $Trigger.Enabled              = $True
        $Settings                     = $Task.Settings
        $Settings                     | % { $_.Enabled = $True ; $_.StartWhenAvailable = $True ; $_.Hidden = $False }
        $Action                       = $Task.Actions.Create( 0 )
        $Action                       | % { $_.Path = "PowerShell" ; $_.Arguments = $Arg }
        $Task.Principal.RunLevel      = 1

        $RootFolder.RegisterTaskDefinition( $TaskName , $Task , 6 , "SYSTEM" , $Null , 1 ) | Out-Null

        $RootFolder.GetTask( $TaskName ).Run( 0 ) | Out-Null 

        While ( $Scheduler.GetRunningTasks( 0 ) | ? { $_.Name -eq $TaskName } ) { Start-Sleep -S 1 }

            $RootFolder.DeleteTask( $TaskName , 0 ) ; Remove-Item $ScriptFile

            If ( Test-Path $ResultFile ) { $Result = Get-Content -Raw -Path $ResultFile | ConvertFrom-Json ; Remove-Item $ResultFile ; Return $Result }
    } 

    Function Get-AutomaticUpdatesOptions 
    {
        Import-Module Microsoft.PowerShell.Management
        $AU                           = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU"
        $Option                       = @( gp $AU -Name    "AUOptions" -ErrorVariable MyError -EA 3 )

        If     ( $Option -ne $null ) { Return $Option.AUOptions } 
        ElseIf ( $myerror          )
        {
            $Option                   = @( gp $AU -Name "NoAutoUpdate" -ErrorVariable         -EA 3 )
            If ( $Option -ne $null ) { Return $Option.NoAutoUpdate }
            ElseIf ( $Myerror )      { $Option = 0 }
        }
        Return $Option
    }

    Function Get-MicrosoftMonitoringAgentStatus 
    {
        Import-Module Microsoft.PowerShell.Management
        $Status = Get-Service -Name HealthService -EA 3
        If     ( $Status        -eq    $Null  ) { @{ Installed = $False ; Running = $False } } 
        ElseIf ( $Status.Status -eq "Running" ) { @{ Installed =  $True ; Running =  $True } }
        Else                                    { @{ Installed =  $True ; Running = $False } }
    }

    Function Get-WindowsUpdateInstallerStatus 
    {
        Import-Module ScheduledTasks
        $ScheduledTask = Get-ScheduledTask | Microsoft.PowerShell.Utility\Select-Object TaskName, State | ? { $_.TaskName -eq "SMEWindowsUpdateInstallUpdates" }
        Return $( If ( $ScheduledTask -ne $Null -and $ScheduledTask.State -eq 4 ) { $True } Else { $False } )
    }

    Function Install-WindowsUpdates
    { 
        Param ( [ Parameter ( Mandatory = $False ) ][ String ] $RestartTime     ,
                [ Parameter ( Mandatory =  $True ) ][  Int16 ] $ServerSelection )

        $Script = @'

        $ObjServiceManager , $ObjSession = "ServiceManager" , "Session" | % { New-Object -ComObject "Microsoft.Update.$_" }

        $ObjSearcher                 = $ObjSession.CreateUpdateSearcher()
        $ObjSearcher.ServerSelection = $ServerSelection
        $ServiceName , $Search       = 'Windows Update' , 'IsInstalled = 0'
        $ObjResults                  = $ObjSearcher.Search( $Search )
        $Updates                     = $ObjResults.Updates
        $FoundUpdatesToDownload      = $Updates.Count
        $NumberOfUpdate              = 10
        $ObjCollectionDownload       = New-Object -ComObject 'Microsoft.Update.UpdateColl'
        $UpdateCount                 = $Updates.Count
    
        Foreach ( $Update in $Updates )
        {
            $Progress = @{  Activity = "Downloading updates"
                              Status = "[ $( $NumberOfUpdate )/$( $UpdateCount )] $( $Update.Title )"
                     PercentComplete = "$( [ Int ]( $NumberOfUpdate / $UpdateCount * 100 ) )" }

	        Write-Progress @Progress ; $NumberOfUpdate ++

    	    "Show Update To Download: $( $Update.Title )" , "Accept Eula" , "Send Update to Download Collection" | % { Write-Debug $_ }
	
            $Update.AcceptEula() ; $ObjCollectionTmp = New-Object -ComObject 'Microsoft.Update.UpdateColl' ; $ObjCollectionTmp.Add( $Update ) | Out-Null

	        $Downloader              = $ObjSession.CreateUpdateDownloader()
            $Downloader.Updates      = $objCollectionTmp

    	    Try {   Write-Debug "Try download update" 
                    $DownloadResult  = $Downloader.Download() }

    	    Catch { If ( $_ -match 'HRESULT: 0x80240044' ) { Write-Warning "Your security policy does not allow a non-administator identity to perform this task" } Return }

    	    Write-Debug "Check ResultCode"

    	    $Status = Switch -Exact ( $DownloadResult.ResultCode ) { 0 { 'NotStarted' } 1 { 'InProgress' } 2 { 'Downloaded' } 3 { 'DownloadedWithErrors' } 4 { 'Failed' } 5 { 'Aborted' } }

	        If ( $DownloadResult.ResultCode -eq 2 ) { Write-Debug 'Downloaded then send update to next stage' ; $ObjCollectionDownload.Add( $Update ) | Out-Null }
        }

        $ReadyUpdatesToInstall       = $ObjCollectionDownload.Count
   
        Write-Verbose "$( Downloaded [ $ReadyUpdatesToInstall ] Updates to Install )"
    
        If ( $ReadyUpdatesToInstall -eq 0 ) { Return }

        $NeedsReboot                 = $False 
        $NumberOfUpdate              = 1
    
        ForEach ( $Update in $ObjCollectionDownload )
        {
            $Progress = @{  Activity = "Installing Updates"
                              Status = " [ $( $NumberOfUpdate )/$( $ReadyUpdatesToInstall )] $( $Update.Title )"
                     PercentComplete = "$( [ Int ]( $NumberOfUpdate / $ReadyUpdatesToInstall * 100 ) )" }

    	    Write-Progress @Progress ; ': $($Update.Title)' , ' collection' | % { Write-Debug "Show update to install $_" }

    	    $ObjCollectionTmp        = New-Object -ComObject 'Microsoft.Update.UpdateColl'
    	    $ObjCollectionTmp.Add( $Update ) | Out-Null

    	    $ObjInstaller            = $ObjSession.CreateUpdateInstaller()
    	    $ObjInstaller.Updates    = $ObjCollectionTmp

    	    Try { Write-Debug 'Try install update'
    		          $InstallResult = $ObjInstaller.Install() }

    	    Catch { If ( $_ -Match 'HRESULT: 0x80240044' ) { Write-Warning 'Your security policy does not allow a non-administator identity to perform this task' } Return }

    	    If ( ! $NeedsReboot ) 
            {
                Write-Debug 'Set instalation status RebootRequired'
	    	    $NeedsReboot         = $InstallResult.RebootRequired } ; $NumberOfUpdate ++
        }

        If ( $NeedsReboot )
        {
	        $WaitTime = 0
            If ( $RestartTime )
            {
                $WaitTime = [ Decimal ]::Round( ( ( Get-Date $RestartTime ) - ( Get-Date ) ).TotalSeconds )
                [ Decimal ]::Round( ( ( Get-Date ) - ( Get-Date ) ).TotalSeconds )
                If ( $WaitTime -lt 0 ) { $WaitTime = 0 }
            }

            Shutdown -R -T $WaitTime -C "SME installing Windows updates"
        }
'@
        If ( $RestartTime ) { $Script = "`$restartTime     = '$restartTime' ; $Script" }
        $Script                       = "`$serverSelection = '$serverSelection' ; $Script"
        $ScriptFile                   = "$env:LocalAppData\Install-Updates.ps1"
        $Script                       | Out-File $ScriptFile
    
        If ( ! ( Test-Path $ScriptFile ) ) { Write-Error "Failed to create file:$ScriptFile" ; Return }
        $TaskName                     = "SMEWindowsUpdateInstallUpdates"
        If ( $Admin -eq 1 ) { $Arg    = "-NoProfile -NoLogo -NonInteractive -ExecutionPolicy Bypass -File $ScriptFile" }
        Else { Write-Warning "To perform some operations you must run an elevated Windows PowerShell console." }

        $Scheduler = New-Object -ComObject Schedule.Service

        For ( $i = 1 ; $i -le 3 ; $i++ )
        {
	        Try { $Scheduler.Connect() ; Break }

	        Catch 
            { 
                If ( $i -ge 3 )
    		    {
                    $Event = @{ LogName   =                         "Application"
                                Source    = "SME Windows Updates Install Updates"
                                EntryType =                               "Error"
                                EventID   =                                    1
                                Message   =   "Can't connect to Schedule Service" }

	    		    Write-EventLog @Event
                        
    			    Write-Error "Can't connect to Schedule service" -EA 4
	    	    }

    		    Else { Start-Sleep -s 1 }
	        }
        }

        $RootFolder                   = $Scheduler.GetFolder( "\" ) 

        If ( $RootFolder.GetTasks( 0 ) | ? { $_.Name -eq $TaskName } )
        {
	        Write-Debug( "Deleting existing task$TaskName" )
	        $RootFolder.DeleteTask( $TaskName , 0 )
        }
            
            $Task                     = $Scheduler.NewTask( 0 )
            $RegistrationInfo         = $Task.RegistrationInfo
            
            $RegistrationInfo         | % { 
                       $_.Description = $TaskName
                            $_.Author = $User.Name
            }
            $Triggers                 = $Task.Triggers
            $Trigger                  = $Triggers.Create( 7 )
            $Trigger.Enabled          = $True
            $Settings                 = $Task.Settings
            $Settings                 | % {
                           $_.Enabled = $True
                $_.StartWhenAvailable = $True
                            $_.Hidden = $False
            }
            $Action                   = $Task.Actions.Create( 0 )
            $Action                   | % { 
                              $_.Path = "PowerShell"
                         $_.Arguments = $Arg
            }
            $Task.Principal.RunLevel  = 1

            $RootFolder.RegisterTaskDefinition( $TaskName , $Task , 6 , "SYSTEM" , $Null , 1 ) | Out-Null
            $RootFolder.GetTask( $TaskName ).Run( 0 ) | Out-Null

            While ( $Scheduler.GetRunningTasks( 0 ) | ? { $_.Name -eq $TaskName } ) { Start-Sleep -S 1 }
            $RootFolder.DeleteTask( $TaskName , 0 )
            Remove-Item $ScriptFile
        }

    Function Set-AutomaticUpdatesOptions # /¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__/
    {
        Param ( [ Parameter ( Mandatory = $True ) ] [ String ] $AUOptions )
        $Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU"
        Switch( $AUOptions ) 
        {           0 { If (     Test-Path $Path   ) { RI       $Path                                             } }
                    1 { If (     Test-Path $Path   ) { SP -Path $Path -Name NoAutoUpdate -Value        0x1 -Force 
                                                       RP -Path $Path -Name    AUOptions                          } 
                        Else                         { NI       $Path                                      -Force
                                                       SP -Path $Path -Name NoAutoUpdate -Value        0x1 -Force } }
            "default" { If ( ! ( Test-Path $Path ) ) { NI       $Path                                      -Force }
                                                       SP -Path $Path -Name    AUOptions -Value $AUOptions -Force
                                                       SP -Path $Path -Name NoAutoUpdate -Value        0x0 -Force } }
    } # //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__/# /¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__/

    Function Get-CimWin32ComputerSystem  { Import-Module CimCmdlets ; Get-CimInstance -Namespace root/cimv2 -ClassName Win32_ComputerSystem  }
    
    Function Get-CimWin32LogicalDisk     { Import-Module CimCmdlets ; Get-CimInstance -Namespace root/cimv2 -ClassName Win32_LogicalDisk     }
    
    Function Get-CimWin32NetworkAdapter  { Import-Module CimCmdlets ; Get-CimInstance -Namespace root/cimv2 -ClassName Win32_NetworkAdapter  }
    
    Function Get-CimWin32OperatingSystem { Import-Module CimCmdlets ; Get-CimInstance -Namespace root/cimv2 -ClassName Win32_OperatingSystem }
    
    Function Get-CimWin32PhysicalMemory  { Import-Module CimCmdlets ; Get-CimInstance -Namespace root/cimv2 -ClassName Win32_PhysicalMemory  }
    
    Function Get-CimWin32Processor       { Import-Module CimCmdlets ; Get-CimInstance -Namespace root/cimv2 -ClassName Win32_Processor       }
    
    Function Get-ClusterInventory # /¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__/
    {
        "CimCmdlets" , "FailoverClusters" | % { Import-Module $_ -EA 3 }
        
        Function getComputerName() { $ComputerSystem = Get-CimInstance Win32_ComputerSystem -EA 3 | Microsoft.PowerShell.Utility\Select-Object Name, DNSHostName            
            If ( $ComputerSystem ) { $ComputerName = $ComputerSystem.DNSHostName ;If ( $Null -eq $ComputerName ) { $ComputerName = $ComputerSystem.Name } ; Return $ComputerName }
            Return $Null }
        
        Function getIsClusterCmdletAvailable() { $Cmdlet = Get-Command "Get-Cluster" -EA 3 ; Return !!$Cmdlet }
        
        Function getClusterCimInstance() { $Namespace = Get-CimInstance -Namespace root/MSCluster -ClassName __NAMESPACE -EA 3
            If ( $Namespace ) { Return Get-CimInstance -Namespace root/mscluster MSCluster_Cluster -EA 3 | Microsoft.PowerShell.Utility\Select-Object fqdn, S2DEnabled }
            Return $Null }
        
        Function getClusterPerformanceHistoryPath() { Return $null -ne ( Get-StorageSubSystem clus* | Get-StorageHealthSetting -Name "System.PerformanceHistory.Path" ) }
        
        Function getClusterInfo()
        {
            $ReturnValues = @{ FQDN = $Null ; isS2DEnabled = $False ; isTsdbEnabled = $False } ; $Cluster = getClusterCimInstance
            If ( $Cluster )  
            { 
                $ReturnValues.FQDN         = $Cluster.FQDN
                $isS2dEnabled              = ! ! ( GM -InputObject $Cluster -Name "S2DEnabled" ) -and ( $Cluster.S2DEnabled -eq 1 ) # <- This logic makes very little sense, it's a double negative.
                $ReturnValues.isS2DEnabled = $IsS2dEnabled
                If ( $IsS2DEnabled ) { $ReturnValues.isTsdbEnabled = getClusterPerformanceHistoryPath } Else { $ReturnValues.isTsdbEnabled = $False }
            }
            Return $ReturnValues
        }

        Function getisClusterHealthCmdletAvailable()    { $CmdLet = Get-Command -Name "Get-HealthFault" -EA 3 ; Return !!$CmdLet }
        Function getIsBritannicaEnabled()               { Return $Null -ne ( gcim -Namespace root/sddc/management -ClassName SDDC_Cluster -EA 3 ) }
        Function getIsBritannicaVirtualMachineEnabled() { Return $null -ne ( gcim -Namespace root/sddc/management -ClassName SDDC_VirtualMachine -EA 3 ) }
        Function getIsBritannicaVirtualSwitchEnabled()  { Return $null -ne ( gcim -Namespace root/sddc/management -ClassName SDDC_VirtualSwitch -EA 3 ) }

        $clusterInfo = getClusterInfo

        $Names  = @( 'Fqdn' , 'IsClusterHealthCmdletAvailable' ,  'IsClusterCmdletAvailable' , 'CurrentClusterNode' ;
                  @( @( '' , 'VirtualMachine' , 'VirtualSwitch' | % { "IsBritannica$_" } ) + 'IsS2D' , 'IsTsdb' | % { "$_`Enabled" } ) )[0,7,8,1,4,5,6,2,3]

        $Values = @( $ClusterInfo | % { $_.FQDN , $_.isS2DEnabled , $_.isTsdbEnabled } ) + 
                  @( getIsClusterHealthCmdletAvailable ; getIsBritannicaEnabled ; getIsBritannicaVirtualMachineEnabled ; getIsClusterCmdletAvailable ; getComputerName )

        $Result = [ PSCustomObject ]{ } ; 0..8 | % { $Result | Add-Member -MemberType NoteProperty -Name $Names[$_] -Value $Values[$_] } ; $Result

    } # /¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__/# /¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__/

    Function Get-ClusterNodes 
    { 
        "CimCmdLets" , "FailoverClusters" | % { Import-Module $_ -EA 3 }

        $Names  = "LogName" , "LogSource" , "ScriptName" ; $Values = "Microsoft-ServerManagementExperience" , "SMEScripts" , $MyInvocation.ScriptName 

        0..2 | % { Set-Variable -Name $Names[$_] -Option Constant -Value $Values[$_] -EA 3 }

        $Names  = "DrainStatus" , "DynamicWeight" , "Name" , "NodeWeight" , "FaultDomain" , "State"

        Function getClusterPowerShellSupport() { $CmdletInfo = Get-Command 'Get-ClusterNode' -EA 3 ; Return $cmdletInfo -and $cmdletInfo.Name -eq "Get-ClusterNode" }

        Function getClusterNodeCimInstances()  { $Cluster    = Get-CimInstance -Namespace root/mscluster MSCluster_Node -EA 3
            Return $Cluster | Microsoft.PowerShell.Utility\Select-Object @{ Name = "DrainStatus" ; Expression = { $_.NodeDrainStatus } } , @( $Names[1..5] | % { "$_" } ) }

        Function getClusterNodePsInstances()   { Return Get-ClusterNode -EA 3 | Microsoft.PowerShell.Utility\Select-Object $Names }

        Function getClusterNodeFqdn( [ String ] $ClusterNodeName ) { Return ( [ System.Net.DNS ]::GetHostEntry( $ClusterNodeName ) ).HostName }

        Function writeToEventLog( [ String ] $Message ) 
        {   Microsoft.PowerShell.Management\New-EventLog   -LogName $LogName -Source $LogSource                                                             -EA 3
            Microsoft.PowerShell.Management\Write-EventLog -LogName $LogName -Source $LogSource -EventId 0 -Category 0 -EntryType Warning -Message $message -EA 3 }

        Function getClusterNodes() 
        {
            $isClusterCmdletAvailable = getClusterPowerShellSupport
            If ( $isClusterCmdletAvailable ) { $ClusterNodes = getClusterNodePsInstances  } Else { $ClusterNodes = getClusterNodeCimInstances }

            $ClusterNodeMap = @{}

            ForEach ( $ClusterNode in $ClusterNodes )
            {
                $ClusterNodeName = $ClusterNode.Name.ToLower()
                Try    {   $ClusterNodeFqdn = getClusterNodeFqdn $ClusterNodeName -EA 3 }
                Catch  {   $ClusterNodeFqdn = $ClusterNodeName
                            writeToEventLog "[$ScriptName]: The fqdn for node '$ClusterNodeName' could not be obtained. Defaulting to machine name '$ClusterNodeName'" }

                $Names  = "FullyQualifiedDomainName" , "Name" , "DynamicWeight" , "NodeWeight" , "FaultDomain" , "State" , "DrainStatus"
                $Values = @( $clusterNodeFqdn , $clusterNodeName ; @( $clusterNode | % { $_.DynamicWeight , $_.NodeWeight , $_.FaultDomain , $_.State , $_.DrainStatus } ) )

                $ClusterNodeResult = [ PSCustomObject ] @{ } ; 0..6 | % { $ClusterNodeResult | Add-Member -MemberType NoteProperty -Name $Names[$_] -Value $Value[$_] }

                $ClusterNodeMap.Add( $ClusterNodeName , $ClusterNodeResult )
            } 
            
            Return $ClusterNodeMap

        } # //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__/# /¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__/

        getClusterNodes

    }


    Function Get-ServerInventory 
    {
        Set-StrictMode -Version 5.0 ; Import-Module CimCmdlets

        Function ConvertOsVersion ( [ String ] $OSVersion )
        {
            [ Ref ] $ParsedVersion = $null ; If ( ! [ Version ]::TryParse( $OSVersion , $ParsedVersion ) ) { Return $Null }
            $Version = [ Version ] $ParsedVersion.Value ; Return New-Object Version -Args $Version.Major , $Version.Minor
        }

        Function isCredSSPEnabled() 
        {

            "Service" , "Client" | % { Set-Variable credSSP$( $_ )Path -Option Constant -Value "WSMan:\localhost\$_\Auth\CredSSP" }

            $CredSSPServerEnabled , $CredSSPClientEnabled = $False , $False

            $CredSSPServerService = gi $CredSSPServicePath -EA 3 
            If ( $CredSSPServerService ) { $CredSSPServerEnabled = [ System.Convert ]::ToBoolean( $credSSPServerService.Value ) }

            $CredSSPClientService = gi $CredSSPClientPath  -EA 3
            If ( $CredSSPClientService ) { $CredSSPClientEnabled = [ System.Convert ]::ToBoolean( $credSSPClientService.Value ) }

            Return ( $CredSSPServerEnabled -or $CredSSPClientEnabled )
        }

        Function isHyperVRoleInstalled() { $VMMSService = Get-Service -Name "VMMS" -EA 3 ; Return $VMMsService -and $VMMsService.Name -eq "VMMS" }

        Function isHyperVPowerShellSupportInstalled() { Return !!( Get-Module -ListAvailable Hyper-V -EA 3 ) }

        Function isWMF5Installed ( [ String ] $OperatingSystemVersion )
        {
            $Names = 6 , 2 | % { "Server201$_" } ; $Values = "10.0" , "6.2"
            0..1 | % { Set-Variable ( $Names[$_] ) -Option Constant -Value ( New-Object Version $Values[$_] ) }

            $Version = ConvertOsVersion $OperatingSystemVersion
            If ( -not $Version ) { Return $False } If ( $Version -ge $Server2016 ) { Return $True }
            Else 
            {
                If ( $Version -ge $Server2012 )
                {
                    $RegistryKeyValue = gp -Path 'HKLM:\SOFTWARE\Microsoft\PowerShell\3\PowerShellEngine' -Name PowerShellVersion -EA 3
                    
                    If ( $RegistryKeyValue -and ( $RegistryKeyValue.PowerShellVersion.Length -ne 0 ) )
                    {
                        $InstalledWmfVersion = [ Version ] $RegistryKeyValue.PowerShellVersion
                        If ( $InstalledWmfVersion -ge [ Version ] '5.0' ) { Return $True } } } }

            Return $False
        }

        Function isUserAnAdministrator() { Return "Windows" | % { IEX "( [ $( $_ )Principal ][ $( $_ )Identity ]::GetCurrent() ).IsInRole( 'Administrator' )" } }

        Function getClusterInformation() 
        {
            $ReturnValues = @{} ; $ReturnValues | % { $_.IsS2dEnabled = $False ; $_.IsCluster = $False ; $_.ClusterFqdn = $Null }
            $Namespace    = gcim -Namespace root/MSCluster -ClassName __NAMESPACE -EA 3
            If ( $Namespace )
            {
                $Cluster  = gcim -Namespace root/MSCluster -ClassName MSCluster_Cluster -EA 3
                If ( $Cluster )
                {
                    $IsS2dEnabled0      = ! ! ( Get-Member -InputObject $Cluster -Name "S2DEnabled" ) -and ( $Cluster.S2DEnabled -gt 0 )
                    $ReturnValues       | % { $_.IsCluster = $True ; $_.ClusterFQDN = $Cluster.FQDN ; $_.IsS2dEnabled = $IsS2dEnabled0 }
                }
            }
            Return $ReturnValues
        }

        Function GetComputerFqdnAndAddress( $ComputerName ) 
        {
            $HostEntry    = [ System.Net.Dns ]::GetHostEntry( $ComputerName ) ; $AddressList = @()
            ForEach ( $Item in $HostEntry.AddressList )
            {   $Names = "IPAddress" , "AddressFamily" ; $Values = $Item | % { $_.ToString() , $_.AddressFamily.ToString() } ; $Address = [ PSCustomObject ]@{ }
                0..1 | % { $Address | Add-Member -MemberType NoteProperty -Name $Names[$_] -Value $Values[$_] } ; $AddressList += $Address }
            $Names = "Fqdn" , "AddressList" ; $Values = $HostEntry.Hostname , $AddressList ; $Result = [ PSCustomObject ]@{ }
            0..1 | % { $Result | Add-Member -MemberType NoteProperty -Name $Names[$_] -Value $Values[$_] }
            Return $Result
        }

        Function GetHostFqdnAndAddress ( $ComputerSystem ) 
        { 
            $ComputerName = $ComputerSystem.DNSHostName
            If ( ! $ComputerName ) { $ComputerName = $ComputerSystem.Name }
            Return GetComputerFqdnAndAddress $ComputerName
        }

        Function getManagementToolsSupportInformation()
        {
            $ReturnValues = @{} ; $ReturnValues | % { $_.ManagementToolsAvailable = $False ; $_.ServerManagerAvailable = $False }
            $Namespaces = gcim -Namespace root/microsoft/windows -ClassName __NAMESPACE -EA 3

            If ( $NameSpaces ) { $ReturnValues | % { $_.ManagementToolsAvailable = ! ! ( $Namespaces | ? { $_.Name -ieq "ManagementTools" } )
                                                     $_.ServerManagerAvailable   = ! ! ( $Namespaces | ? { $_.Name -ieq "ServerManager"   } ) } }
            Return $ReturnValues
        }

        Function isRemoteAppEnabled() 
        {
            Set-Variable Key -Option Constant -Value "HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\TSAppAllowList"
            $RegistryKeyValue = gp -Path $Key -Name fDisabledAllowList -EA 3
            If ( -not $RegistryKeyValue ) { Return $False } Return $RegistryKeyValue.fDisabledAllowList -eq 1
        }

        Function getOperatingSystemInfo() { Return Get-CimInstance Win32_OperatingSystem | Microsoft.PowerShell.Utility\Select-Object csName, Caption, OperatingSystemSKU, Version, ProductType }

        Function getComputerSystemInfo() 
        {
            $Items = "TotalPhysicalMemory" , "DomainRole" , "Manufacturer" , "Model" , "NumberOfLogicalProcessors" , "Domain" , "Workgroup" , "DNSHostName" , "Name" , "PartOfDomain"
            Return Get-CimInstance Win32_ComputerSystem -EA 3 | Microsoft.PowerShell.Utility\Select-Object $Items
        }

        $OSV  = getComputerSystemInfo
        $FQDN = getHostFqdnAndAddress $computerSystem               | % { $_.Fqdn ; $_.AddressList }
        $MGMT = getManagementToolsSupportInformation                | % { $_.ManagementToolsAvailable ; $_.ServerManagerAvailable }
        $CSRV = getClusterInformation -ErrorAction SilentlyContinue | % { $_.IsCluster ; $_.ClusterFQDN ; $_.IsS2dEnabled }

        $Result = [ PSCustomObject ] @{                                  IsAdministrator             = isUserAnAdministrator              ; 
            OperatingSystem             = getOperatingSystemInfo       ; ComputerSystem              = getComputerSystemInfo              ; 
            Fqdn                        = $FQDN[0]                     ; AddressList                 = $FQDN[1]                           ; 
            Hostname                    = hostname                     ; NetBios                     = $env:ComputerName                  ; 
            IsManagementToolsAvailable  = $MGMT[0]                     ; IsServerManagerAvailable    = $MGMT[1]                           ; 
            IsWmfInstalled              = isWMF5Installed $OSV.Version ; IsCluster                   = $CSRV[0]                           ; 
            ClusterFqdn                 = $CSRV[1]                     ; IsS2dEnabled                = $CSRV[2]                           ; 
            IsHyperVRoleInstalled       = isHyperVRoleInstalled        ; IsHyperVPowershellInstalled = isHyperVPowerShellSupportInstalled ; 
            IsCredSSPEnabled            = isCredSSPEnabled             ; IsRemoteAppEnabled          = isRemoteAppEnabled                 }

        $Result

    }

