# ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯   //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//  [ Secure Digits Plus LLC | Hybrid | Desired State Controller ]  \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯     ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯     ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯                 Dynamically Engineered Digital Security                    ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\                    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                       //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//   Application Development | Virtualization | Network and Hardware Magistration   \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//   https://www.securedigitsplus.com | Server-Client | Seedling-Spawning Script    \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\___¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ___//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   [ Provisional Author : Michael C Cook Sr. | "The Buck Stops Here" ]    //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//   ____    ____    ____    ____    ____    ____    ____    ____    ____   \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯  
#\\  [ Hybrid-DSC ] @: Loads All Table/Message Echo Wrappers, GUI, Networking Functions 
#//   ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____      
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\___  
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
# ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯  

# ____                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function New-SubTable # Converts array of keys and values into an Object      ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
        
        [ CmdLetBinding ( ) ] Param (

            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage =  "Section Items" ) ][ String [] ]  $Items ,
            [ Parameter ( Position = 1 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Section Values" ) ][ String [] ] $Values )

        $Table = [ PSCustomObject ]@{ }                                                                                       # Declares an empty table

        If ( $Items.Count -eq $Values.Count )                                                                            # Prepares the key/value pairs
        {
            If ( $Items.Count -gt 1 ) { $Count = 0..( $Items.Count - 1 ) }
            $Count | % { $Table | Add-Member -MemberType NoteProperty -Name "Item:$_" -Value @{ ID = "$( $Items[$_] )" ; Value = "$( $Values[$_] )" } }
        }

        If ( $Items.Count -ne $Values.Count ) { Throw '$Items -ne $Values' }                                                           # Error handling

        Return $Table                                                                                                              # Outputs the object

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function New-Table # Converts array of objects into a single object           ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        [ CmdLetBinding ( ) ] Param (

            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Name or Header" ) ][     String    ] $Title ,
            [ Parameter ( Position = 1 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Section Quantity" ) ][      Int    ] $Depth ,
            [ Parameter ( Position = 2 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Section Names" ) ][      String [] ] $ID    ,
            [ Parameter ( Position = 3 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Subtables"  ) ][ PSCustomObject [] ] $Table )

        $Object = [ PSCustomObject ]@{ Class = $Title }                                                                           # Title and Sync Root

        If ( ( $ID.Count -ne $Depth ) -or ( $Table.Count -ne $Depth ) ) { Throw '$Depth -ne $ID.Count or $Table.Count' }               # Error handling
        If ( $Depth -eq 1 ) { $Count = 1 } If ( $Depth -gt 1 ) { $Count = 0..( $Depth - 1 ) }                                   # Single/Multiple Count

        $C = $Null                                                                                                          # Ensures index starts at 0

        $Count | % {                                                                                                                  # Begins the loop
    
            If ( $Depth -gt 1 )                                                                                                   # If multiple objects
            {   If ( $C -ne $Null ) { $C = $C + 1 } If ( $C -eq $Null ) { $C = 0 } $Index = $ID[$C] ; $Section = $Table[$C] }

            If ( $Depth -eq 1 )                                                                                                    # If a single object
            {   $C = 0 ; $Index = $ID ; $Section = $Table }

            $Object | Add-Member -MemberType NoteProperty -Name "ID:$C" -Value $Index                           # ^ Same core logic used in either case
            $Keys = @( $Section | GM | ? { $_.MemberType -eq "NoteProperty" } | % { $_.Name } )

            ForEach ( $S in $Keys )                                                                             # Prepares the subtable key/value pairs
            {   $SubTable = [ Ordered ]@{ }                                                                                      # Declares empty table
                ForEach ( $K in $Keys )                                                                                                  # Outputs info
                {   $Section.$K | % { $SubTable.Add( "$K" , @{ ID = $_.ID ; Value = $_.Value } ) } } } 

            $Object | Add-Member -MemberType NoteProperty -Name "Section:$C" -Value $SubTable                             # Outputs temporary hashtable
        }

        Return $Object

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Write-Echo # Modifies Write-Output to stylize strings/arrays/tables  ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        [ CmdLetBinding ( ) ] Param (
            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , ParameterSetName = "0" ) ][ Switch ]        $Action ,
            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , ParameterSetName = "1" ) ][ String ]      $Function ,
            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , ParameterSetName = "2" ) ][ Array  ]         $Array ,
            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , ParameterSetName = "3" ) ][ PSCustomObject ] $Table ,
            [ Parameter ( Position = 0 , Mandatory = $True , ParameterSetName = "4" ) ][ Switch ] $Free ,
            [ Parameter ( Position = 0 , Mandatory = $True , ParameterSetName = "5" ) ][ Switch ] $Foot ,
            [ Parameter ( Position = 1 , Mandatory = $True , ParameterSetName = "0" ) ][ String ] $Type ,
            [ Parameter ( Position = 2 , Mandatory = $True , ParameterSetName = "0" ) ][ String ] $Info ,
            [ Parameter ( Position = 1 , ParameterSetName = "2" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "3" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "4" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "5" ) ][ Switch ] $Wrap ,
            [ ValidateSet ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ) ]
            [ Parameter ( Position = 3 , ParameterSetName = "0" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "1" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "2" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "3" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "4" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "5" ) ][ Alias ( "F" )][ String ] $ForegroundColor ,
            [ ValidateSet ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ) ]
            [ Parameter ( Position = 4 , ParameterSetName = "0" ) ]
            [ Parameter ( Position = 3 , ParameterSetName = "1" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "2" ) ]
            [ Parameter ( Position = 3 , ParameterSetName = "3" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "4" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "5" ) ][ Alias ( "B" )][ String ] $BackgroundColor ,
            [ Parameter ( Position = 5 , ParameterSetName = "0" ) ]
            [ Parameter ( Position = 4 , ParameterSetName = "1" ) ]
            [ Parameter ( Position = 3 , ParameterSetName = "2" ) ]
            [ Parameter ( Position = 4 , ParameterSetName = "3" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "4" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "5" ) ][ Alias ( "L" )][ String ] $Log )

        Begin                                                                                                                        # Selects textures
        {
            $B  = @{ 0 = 0..1 ; 1 = 1..0 } ; $Z = "  " , "¯-" , "-_" | % { $_ * 54 } ; $S = " // " , " \\ " ; $F = "/¯¯\" , "\__/" 
            $FR = 0..1 | % { ( $F[( $B[$_] )] ) * 13 -join '' }
            $D  = 0..1 | % { $X , $Y = $B[$_][0..1] ; "$( $S[$X] + $FR[$_] + $F[$X] + $S[$Y] )" }
            $L , $R = $S , $S[1..0] ; $LI = 0..1 | % { $L[$_] + $Z[0] + $R[$_] } ; 
            $OP = @( ) ;
        }

        Process                                                                                                                     # Process Selection
        {   
            If (   $Wrap ) { $OP += "  $( "_" * 112 )  " , $D[0] , $D[1] , " //$( "¯" * 110 )\\ " , $LI[1] }                              # Top Wrapper

            If ( $Action )                                                                                                             # Action Wrapper
            {   $T , $I = $Type , $Info                                                                                    # Concat Type/Info Variables
                If ( $T.Length -gt 20 ) { $T = " $( $T.SubString( 0 , 20 ) )...." }                                              # For Left side length
                Else                    { $T = $T | % { "$( " " * ( 25 - $_.Length ) )$_" } } 
                If ( $I.Length -gt 75 ) { $I = $I.SubString( 0 , 75 ) + ".... " }                                               # For Right side length
                Else                    { $I = $I | % { "$_$( " " * ( 80 - $_.Length ) )" } }
                
                $ST , $SI = ( 25 - $T.Length ) , ( 80 - $I.Length ) | % { " " * $_ }                                  # Calculate Type/Info Positioning
                $Sub = "$( $S[1] )$ST$T : $I$SI$( $S[0] )" ; $AT , $AB = 1..2 | % { $S[0] + $Z[$_] + $S[1] }

                $OP += "" , $AT , $Sub , $AB , ""                                                                                     # Output to Array
            }

            If ( $Function )                                                                                                         # Function Wrapper
            {   $FA = $Function ; If ( $FA.Length -gt 58 ) { $FA = "$( $FA.SubString( 0 , 58 ) )..." } 
                "[ $FA ]" | % { $FA = "$_$( "_" * ( 65 - $_.Length ) )" }

                $OP += " ____ $( " " * 71  ) $( ( "____    "        ) * 4 )____  " , 
                       "//¯¯\\$( "_" * 71  )/$( ( $F[0..1] -join '' ) * 4 )/¯¯\\ " , 
                       "\\__//$( "¯" * 71  )\$( ( $F[1..0] -join '' ) * 4 )\__// " , 
                       " ¯¯¯\\___$( $FA )___/$( ( $F[0..1] -join '' ) * 4 )/¯¯¯  " ,
                       "     ¯$( "¯" * 71  )¯$( ( "    ¯¯¯¯"        ) * 4 )      "
            }

            If (  $Array ) { $Array | % { $OP += $_ } }                                                                                 # Array Wrapper

            If (  $Table )                                                                                                          # Hashtable Wrapper
            {   
                $Index = @( ) ; $Section = @( ) ; $Name = $Null ; $Item = $Null ; $C = $Null                         # Open Arrays, & Nullify Variables
                $ID = $Table | GM | ? { $_.MemberType -eq "NoteProperty" } 
                $ID | ? { $_.Name -eq "Class" } | % { $Title = $Table.$( $_.Name ) }                                                    # Title Wrapper

                $Title = $Title.Replace( ' ' , '-' ) | % { "[ $_ ]" }
                If ( $Title.Length -gt 103 ) { $Title = "$( $Title.Substring( 0 , 103 ) ) ... " }

                $TT = 108 - $Title.Length ; $TX = $TT % 4 ; $TY = ( $TT - $TX ) / 4 ; $TL , $TR = "_¯" , "¯_" | % { $_ * $TY }
                $T = ( $Title | % { "$_" , "$_-" , "$_ " , " $_ -" } )[ $TX ] ; $Title = $S[0] + $TL + $T + $TR + $S[1] ; 
                $OP += $Title , $LI[1]                                                                                                 # Title -> Array
                
                $ID | ? { $_.Name -like      "*ID:*" } | % { $Index   += $Table.$( $_.Name ) }                                            # ID Selector
                $ID | ? { $_.Name -like "*Section:*" } | % { $Section += $Table.$( $_.Name ) }                                       # Section Selector

                $Count = $Index.Count - 1
                $Total = 0                                                                                              # Starts the count ( Critical )

                If ( $Count -gt 0 ) { $Count = 0..$Count }

                $Count | % {

                    If ( $Index.Count -gt 1 )                                                                                             # If Multiple
                    {   
                        If   ( $C -ne $Null ) { $C = $C + 1 }                                                                        # Starts the index
                        If ( ( $C -eq $Null ) -and ( $Name -eq $Null ) ) { $C =      0 }
                        $Name = $Index[$C] ; $Item = $Section[$C]
                    }

                    If ( $Index.Count -eq 1 ) { $Name = [ String ]$Index ; $Item = $Section }                                               # If Single
                    If ( $Name.Length -gt 93 ) { $Name = "$( $Name.Substring( 0 , 93 ) ) ... " }

                    $U = 98 - $Name.Length ; $V = $Total % 2 ; $W = ( 1 - $V )                                                       # Process Sections
                    $SHeader = "_" , "¯" | % { "$( $L[$V] + ( "$_" * 108 ) + $R[$V] )" }
                    $SLine = $L[$W] + ( "-" * 10 ) + $Name + ( "-" * $U ) + $R[$W]
                    
                    $OP += $SHeader[0] , $SLine , $SHeader[1]
                    
                    $Total = $Total + 3

                    $Keys = @( $Item.Keys )

                    ForEach ( $IX in ( 0..( $Item.Keys.Count - 1 ) ) )                                                              # Process Key Pairs
                    {
                        $Item."Item:$IX" | % { $Key = $_.ID ; $Value = $_.Value } ; $Y = $Total % 2

                        If (   $Key.Length -gt 20 ) {   $Key = $Key.SubString( 0 , 20 ) + " ... " } 
                        Else                        {   $Key = $Key | % { "$( " " * ( 25 - $_.Length ) )$_" } }
                        If ( $Value.Length -gt 75 ) { $Value = $Value.SubString( 0 , 75 ) + " ... " } 
                        Else                        { $Value = $Value | % { "$_$( " " * ( 80 - $_.Length ) )" } }

                        $OP += "$( $L[$Y] + $Key ) : $( $Value + $R[$Y] )" ; $Total ++
                    }
                }
            }

            If ( $Free )
            {
                $FL  = " // /¯¯\\    " , " \\ \__//    " ; $RL = "    //¯¯\ \\ " , "    \\__/ // " ; $B1 = "[=]" ; $B2 = "\_/"      # Compression Index
                $BL = "$B1$B2$B1" ; $WL = "| |" ; $S1 = "  *   " * 6 ; $S2 = "$( "     *" * 5 )      " 
                $A1 = "//¯" ; $A2 = "\\ " ; $A3 = "// " ; $A4 = "\\_"
                $T1 = "¯" * 48 ; $T2 = "_" * 48 ; $T3 = "_" * 32 ; $T4 = "¯" * 32 
                $T5 = " " * 32 ; $T6 = "_" * 17 ; $T7 = "¯" * 17 ; $T8 = " " * 28 ; $X1 = "$A2$S1]$T2//" ; $X2 = "$A3$S2]$T1\\"

                $ST  = "Beginning the fight against Technological Tyranny and Cyber Criminal Activities" ,                                 # String Dex
                       "Dynamically Engineered Digital Security" , "Application Development - Virtualization" , 
                       "Network & Hardware Magistration" , "What America Once Stood For" , "HYBRID" , "BY" , "SECURE-DIGITS-PLUS-LLC" , 
                       "MICHAEL C COOK SR" , "A Heightened Sense Of Security"

                $EC  = 0..3 + 9 | % { $ST[$_] } | % { "[ $_ ]" } ; $BR  = 5..8 | % { $ST[$_] } | % { "$( $_.ToCharArray() )" }    # String Manipulation
                $DA  = ( "m" , "d" , "Y" | % { Get-Date -UFormat "%$_" } | % { "$( $_.ToCharArray() )" } ) -join ' / ' ; 
                $Sig = $DA + '  |  ' + $BR[3].Replace( '   ' , '  ' )

                $Out = @( )

                If ( !$Wrap ) { $OP += "  $( "_" * 112 )  " , $D[0] , $D[1] , " // /¯¯\\   $( ( "¯¯¯¯    " ) * 11 )¯¯¯¯   //¯¯\ \\ " }
                If (  $Wrap ) { $OP += " // /¯¯\\$( " " * 98 )//¯¯\ \\ " }

                # Utter Insanity [ I would never recommend going this far with this... but I did it to make a point ]
                # ----- --------   -       ----- ---------                                             ---- - -----

                $Out += "   $( $EC[0] )    " , " $( "_" * 88 ) " , "$A1$( "¯" * 36 )]$T1\\" , "$X1" ,  "$X2" ,                    # Yeah, it's the flag
                "$A2$S1]___$( $EC[1] )__//" , "$X2" , "$X1" , "$X2" , "$A2$S1]__$(  $EC[2] )__//" , "$X2" , "$X1" , "$X2" ,       # <---  ---- --- ----
                "$A2$S1]_______$( $EC[3] )______//" , "$A3    $( $ST[4] )     ]$T1\\" , "$A2$( "_" * 36 )]$T2//" , 
                "$A3$( "¯" * 84 )¯\\" , "$A4$T3$BL$B2$BL$T3//" , "$A1$T4$WL$( "¯" * 15 )$WL$T4\\" , "$A4$T3$B1  $( $BR[0] )  $B1$T3//" , 
                "$A1$T4$WL  $( "¯" * 11 )  $WL$T4\\" , "$A4$T6$( $BL * 2 )$( " " * 6 )$( $BR[1] )$( " " * 6 )$( $BL * 2 )$T6//" , 
                "$A1$T7$WL$( "¯" * 15 )      $( "¯" * 3 )      $( "¯" * 15 )$WL$T7\\" , "$A4$T6$B1 $( $BR[2] ) $B1$T6//" , 
                "$A1$T7$B2 $( "¯" * 43 ) $B2$T7\\" , "$A4$( "_" * 10 )$( $BL * 3 )$B1\___/$B1$( $BL * 3 )$( "_" * 10 )//" , 
                "$A1$( "¯" * 10 )$B1$( "¯" * 59 )$B1$( "¯" * 10 )\\" , "$A4$( "_" * 10 )$B1  $( $Sig )   $B1$( "_" * 10 )//" , 
                " $( "¯" * 15 )  $T7¯¯     $( "¯" * 30 )   $( "¯" * 14 ) " , "$T8$( $EC[4] )$T8"

                $C = 1
                $Out | % { $Y = $C % 2 ; $OP += "$( $FL[$Y] )$_$( $RL[$Y] )" ; $C++ }

                If (  $Wrap ) { $OP += " \\ \__//    $T8$( "¯" * 34 )$T8    \\__/ // " }
                If ( !$Wrap ) { $OP += " \\ \__//   $( ( "____    " ) * 11 )____   \\__/ // " , $D[0] , $D[1] , "  $( "¯" * 112 )  " }
            }

            If ( $Foot )
            {
                $FX = $F[0,1,0,1,0] , $F[1,0,1,0,1] , $F[0,1,0,1] , $F[1,0,1,0] , $F[1,0,1] , $F[0,1,0]                      # Block Selection / Concat
                $F1 , $F2 , $F3 , $F4 , $F5 , $F6  = $FX | % { $_ -join '' } ; $F7 = ( ( $F[1,0] ) * 13 + $F[1] ) -join ''

                $ST = "Secure Digits Plus LLC" , "Hybrid | Desired State Controller" , "Dynamically Engineered Digital Security" ,         # String Dex
                "Application Development" , "Virtualization" , "Network and Hardware Magistration" , "https://www.securedigitsplus.com" ,
                "Server-Client" , "Seedling-Spawning Script" , "You've Just deployed a heightened sense of security"

                $Focus = "$( "-="* 7 | % { "$_-[ $( $ST[2] ) ]-=$_" } )"
                $Title , $Strength , $Domain = $ST[0,1] , $ST[3,4,5] , $ST[6,7,8] | % { $_ -join ' | ' } 

                $Out = @( "$F1\    $( "_" * 58 )    /$F1" , "$F2/    $( $Title )    \$F2" , "$F3/¯¯¯     $( "¯" * 58 )     ¯¯¯\$F4" ,     # Output Prep
                "$F5/¯¯¯ $( $Focus  ) ¯¯¯\$F5"  , "$F6\    $( "¯" * 15 )$( " " * 43 )$( "¯" * 16 )    /$F6" , 
                "$F5/   $( $Strength )   \$F5"  , "$F6\   $( "¯" * 76  )   /$F6" , "$F5/   $(   $Domain )    \$F5" , 
                "$F6\___$( "¯" * 75  ) ___/$F6" , "$F4\___$( " " * 8 )$( $ST[9] )$( " " * 9 )___/$F3" , 
                "$F1\___$( ( ( " " * 4 ) + ( "_" * 4 ) ) * 7 )    ___/$F1" , "$F7" )

                If ( !$Wrap ) { $OP += "  $( "_" * 112 )  " }                                                                          # Send to Output

                $C = 0
                $Out | % { $Y = $C % 2 ; $OP += "$( $L[$Y] )$_$( $R[$Y] )" ; $C ++ }

                If ( !$Wrap ) { $OP += "  $( "¯" * 112 )  " }
            }

            If ( $Wrap ) 
            { 
                If ( ( $OP.Count | Select -Last 1 ) % 2 -ne 0 ) { $OP += $LI[0] } 
                $OP += " \\$( "_" * 110 )// " , $D[0] , $D[1] , "  $( "¯" * 112 )  " 
            }
        }

        End  
        {             
            If ( (  $ForegroundColor ) -and (  $BackgroundColor ) ) { $OP | % { Write-Host -F $ForegroundColor -B $BackgroundColor $_ } }
            If ( (  $BackgroundColor ) -and ( !$ForegroundColor ) ) { $OP | % { Write-Host -B $BackgroundColor $_ } }
            If ( (  $ForegroundColor ) -and ( !$BackgroundColor ) ) { $OP | % { Write-Host -F $ForegroundColor $_ } }
            If ( ( !$ForegroundColor ) -and ( !$BackgroundColor ) ) { $OP | % { Write-Host $_ } }
            If ( $Log ) { "$( ( "Y" , "m" , "d" | % { Get-Date -UFormat "%$_" } ) -join '' )_$Log.log" 
            
            }
        }
    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Convert-XAMLToWindow # Modified, originally by Dr. Tobias Weltner    ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        Param ( [ Parameter ( Mandatory ) ] [ String ] $XAML , [ String [] ] $NE = $Null , [ Switch ] $PassThru ) 

        @( "Framework" , "Core" | % { "Presentation$_" } ) + "WindowsBase" | % { Add-Type -AssemblyName $_ } 
 
        $NR = [ XML.XMLReader ]::Create( [ IO.StringReader ] $XAML ) ; $OP = [ Windows.Markup.XAMLReader ]::Load( $NR ) 
        
        $NE | % { $OP | Add-Member -MemberType NoteProperty -Name $_ -Value $OP.FindName( $_ ) -Force }
 
        If ( $PassThru ) { $OP } Else { $Null = $GUI.Dispatcher.InvokeAsync{ $OP = $GUI.ShowDialog() ; SV -Name OP -Value $OP -Scope 1 }.Wait() ; $OP }

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Show-WPFWindow # Modified, originally by Dr. Tobias Weltner          ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________//¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
        
        Param ( [ Parameter ( Mandatory ) ] [ Windows.Window ] $GUI )
        $OP = $Null ; $Null = $GUI.Dispatcher.InvokeAsync{ $OP = $GUI.ShowDialog() ; SV -Name OP -Value $OP -Scope 1 }.Wait() ; $OP 

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-NetworkInfo # Obtains DNS, Subnet, IPV4, NetBIOS                 ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
    
        [ CmdLetBinding () ] Param ( 
        
            [ Parameter ( Position = 0 , ParameterSetName = "0" ) ][ Switch ] $DNS     , 
            [ Parameter ( Position = 0 , ParameterSetName = "1" ) ][ Switch ] $Subnet  ,
            [ Parameter ( Position = 0 , ParameterSetName = "2" ) ][ Switch ] $IPv4    ,
            [ Parameter ( Position = 0 , ParameterSetName = "3" ) ][ Switch ] $NetBIOS ,
            [ Parameter ( Position = 1 , ParameterSetName = "3" ) ][ Switch ] $Full    ,
            [ Parameter ( Position = 2 , ParameterSetName = "3" ) ][ Switch ] $DC      )
        
        $I = $( If ( $DNS ) { "Connection-Specific DNS Suffix" } If ( $Subnet ) { "Subnet Mask" } If ( $IPv4 ) { "IPv4 Address" } Else { $Null } ) 
        $OP = @( )

        If ( $I -ne $Null )
        {
            ipconfig /all | ? { $_ -like "*$i*" } | % { $_.Split( ':' )[1].Replace(" ","") } | ? { $_.Length -ne 0 } | % { 

                If ( $_ -notin $OP ) { $OP += $_ } 
            }

            "(Preferred)" | ? { $OP -like "*$_*" } | % { $OP = $OP.Replace( "$_" , "" ) }

            If ( $OP -eq $Null ) { $OP += "<NOT DETECTED>" }
        }

        If ( $NetBIOS )
        {
            $Y , $Item , $Count , $NBT = 0..3 | % { $Null } ; $C = 0
            $NBTStat = @( NBTSTAT -n | ? { $_ -like "*Registered*" } ) ; $NBTStat | % { $C ++ }
            $X       = $NBTStat.Count - 1

            $NBTStat | % { 

                If ( $X -gt 0 ) 
                { 
                    If ( $Y -ne $Null ) { $Y ++ } If ( ( $NBT -eq $Null ) -and ( $Y -eq $Null ) ) { $NBT = 0..$X ; $Y = 0 } ; $Item = $NBTStat[$Y]
                }

                If ( $X -eq 0 ) 
                { 
                    $Item = $NBTStat 
                }
                
                $Z = $Item | % { $_[0..18] , $_[19..22] , $_[25..36] | % { $_ -join '' } | % { $_.Replace( ' ' , '' ) } }
                
                If ( $X -gt 0 ) { $NBT[$Y] = [ PSCustomObject ]@{ Name = $Z[0] ; ID = $Z[1] ; Type = $Z[2] } }
                If ( $X -eq 0 ) {     $NBT = [ PSCustomObject ]@{ Name = $Z[0] ; ID = $Z[1] ; Type = $Z[2] } }
            }

            If (  $Full ) { $OP += $NBT }

            If ( !$Full ) 
            { 
                $OP += $NBT | ? { $_.ID -eq "<00>" -and $_.Type -eq  "GROUP" } | % { $_.Name } 
                If ( $DC )
                {
                    $NBID = $NBT | ? { $_.ID -eq "<1C>" -and $_.Type -eq "UNIQUE" } | % { $_.Name } 
                    $OP += If ( $NBID -ne $Null ) { $NBID } Else { "<NOT DETECTED>" }
                    $OP = $OP -join ' '
                }
            }
        }

        Return $OP

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-HostRange # Obtains a range of potential hosts                   ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        $Class  = "Network" , "A" , "B" , "C" , "D / MC" , "E / R&D" , "Broadcast" , "Loopback"
        $Range  = [ Ordered ]@{ 0 = 0 ; 1 = 1..126 ; 2 = 128..191 ; 3 = 192..223 ; 4 = 224..239 ; 5 = 240..254 ; 6 = 6 ; 7 = 127 }
        $IP     = ( Get-NetworkInfo -IPv4 ).Split( '.' ) ; $SM = ( Get-NetworkInfo -Subnet ).Split( '.' )
            
        $Full   = @( ) ; $Concat = 0 ; $Close  = 0

        ForEach ( $I in 0..3 )
        {
            If ( $Close -eq 0 )
            {
                If ( $SM[$I] -eq 255 ) { $Full += $IP[$I] } If ( $SM[$I] -ne 255 ) { $Concat = 1 }
                If ( $Concat -eq 1 )
                {
                    $NW   = $Full -Join "."
                    $Full = $NW

                    If ( $SM[$I] -eq 0 )
                    {
                        $NW , $Start , $End , $BC = 0 , 1 , 254 , 255 | % { "$Full.$_" }
                    }

                    Else
                    {
                        ForEach ( $J in 1..5 )
                        { 
                            If ( $SM[$I] -in $Range[$J] )
                            {
                                $X  = $Range[$J]
                                $Y  = $X | Select -First 1  , $X | Select -Last  1
                                $Y += $Y[1] + 1
                                    
                                $NW , $Start , $End , $BC = $Y[0..2] | % { "$Full.$_" }
                            }
                        }
                    }

                    $Close = 1
                }
            }
            
            If ( $Close -eq 1 )
            {
                If ( $I -ne 3 )
                {
                    $NW , $BC , $Start , $End | % { "$_.0" }
                }
            }
        }
            
        $DHCP = [ Ordered ]@{ 
            Class      = ForEach ( $k in 1..5 ) { If ( $IP[0] -in $Range[$k] ) { "Class $( $Class[$k] ) Address" } }
            IPAddress  = $IP   -Join "." 
            SubnetMask = $SM   -Join "."
            Network    = $Full   
            Start      = $Start
            End        = $End 
            Broadcast  = $BC   }
    
        Echo $DHCP
    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-HostMask # Obtains NetMask                                       ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
        
        $Base = 1 , 2 , 4 , 8 , 16 , 32 , 64 ; $Hash = [ Ordered ]@{ }
        ForEach ( $y in ( 0..( $Base.Count - 1 ) ) )
        {
            $X = $Base[$y] ; $Q = 256 / $X
            If ( $X -eq 1 )
            {
                $X | % { $A = 256 - $Q ; $B = $A + $_ ; $C = 256 - ( $_ * 2 ) ; $D = 256 - $_ }
                $Hash.$y = [ Ordered ]@{ Netmask = $A ; Network = $B ; Hosts = $C ; Broadcast = $D }
            }

            If ( $X -gt 1 )
            {
                $A , $B , $C , $D = 0..3 | % { @( ) }
                    
                $A += 0..( $X - 1 ) | % { $Q * $_ } ; $B += $A | % { $_ + 1 } ; $C += $A | % { $_ + ( $Q - 2 ) } ; $D += $A | % { $_ + ( $Q - 1 ) }

                $Hash.$y = [ Ordered ]@{ Netmask = @( $A ) ; Network = @( $B ) ; Hosts = @( $C ) ; Broadcast = @( $D ) }
            }
        }
        Return $Hash
    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-NetworkHosts # Gets a range of potential host addresses          ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        $Return = @( ) ; $List = @( ) ; $ARP = @( arp -a ) ; $Net = ( Get-HostRange ).Network

        Foreach ( $i in ( 0..( $ARP.count - 1 ) ) )
        { 
            If ( ( $ARP[$i] -like "*$Net*" ) -and ( $ARP[$i] -notlike "*Interface*" ) ) { $List += $ARP[$i] }
        }

        ForEach ( $i in ( 0..( $List.Count - 1 ) ) )
        {
            $X = $List[$i]
            $Rarp = @{ INet = @( ) ; Phy = @( ) ; Type = @( ) }
            $INet , $Phy , $Type = 0..2 | % { @( ) }
            $X[ 0..23] | ? { $_ -ne " " } | % {   $INet += $_ } 
            $X[24..40] | ? { $_ -ne " " } | % {    $Phy += $_ }
            $X[41..56] | ? { $_ -ne " " } | % {   $Type += $_ }

            $RARP | % {   $_.INet +=   $INet -join ''
                           $_.Phy +=    $Phy -join ''
                          $_.Type +=   $Type -join '' }

            $Return += $RARP
        }
    
        $Return | ? { $_ -ne $Null } | % { Return $_ }
    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
        Write-Echo -Free -F 10 -B 0 ; Sleep 1 # What Free Actually Means         #¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
     #\______________________________________________________________________________//¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
     #¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                                                                   
