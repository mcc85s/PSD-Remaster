# ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯   //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//  [ Secure Digits Plus LLC | Hybrid | Desired State Controller ]  \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯     ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯     ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯                 Dynamically Engineered Digital Security                    ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\                    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                       //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//   Application Development | Virtualization | Network and Hardware Magistration   \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//   https://www.securedigitsplus.com | Server-Client | Seedling-Spawning Script    \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\___¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ___//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   [ Provisional Author : Michael C Cook Sr. | "The Buck Stops Here" ]    //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//   ____    ____    ____    ____    ____    ____    ____    ____    ____   \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
#//¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯  
#\\  [ Hybrid-DSC ] @: Loads All Table/Message Echo Wrappers, GUI, Networking Functions 
#//   ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____      
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\___  
#//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
# ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯  
    Using Namespace System.Net.NetworkInformation
# ____                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function New-SubTable # Converts array of keys and values into an Object      ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
        
        [ CmdLetBinding ( ) ] Param (

            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage =  "Section Items" ) ][ String [] ]  $Items ,
            [ Parameter ( Position = 1 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Section Values" ) ][ String [] ] $Values )

        $Table = [ PSCustomObject ]@{ }                                                                                       # Declares an empty table

        If ( $Items.Count -eq $Values.Count )                                                                            # Prepares the key/value pairs
        {
            If ( $Items.Count -gt 1 ) { $Count = 0..( $Items.Count - 1 ) }
            $Count | % { $Table | Add-Member -MemberType NoteProperty -Name "Item:$_" -Value @{ ID = "$( $Items[$_] )" ; Value = "$( $Values[$_] )" } }
        }

        If ( $Items.Count -ne $Values.Count ) { Throw '$Items -ne $Values' }                                                           # Error handling

        Return $Table                                                                                                              # Outputs the object

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function New-Table # Converts array of objects into a single object           ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        [ CmdLetBinding ( ) ] Param (

            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Name or Header" ) ][     String    ] $Title ,
            [ Parameter ( Position = 1 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Section Quantity" ) ][      Int    ] $Depth ,
            [ Parameter ( Position = 2 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Section Names" ) ][      String [] ] $ID    ,
            [ Parameter ( Position = 3 , Mandatory = $True , ValueFromPipeline = $True , HelpMessage = "Subtables"  ) ][ PSCustomObject [] ] $Table )

        $Object = [ PSCustomObject ]@{ Class = $Title }                                                                           # Title and Sync Root

        If ( ( $ID.Count -ne $Depth ) -or ( $Table.Count -ne $Depth ) ) { Throw '$Depth -ne $ID.Count or $Table.Count' }               # Error handling
        If ( $Depth -eq 1 ) { $Count = 1 } If ( $Depth -gt 1 ) { $Count = 0..( $Depth - 1 ) }                                   # Single/Multiple Count

        $C = $Null                                                                                                          # Ensures index starts at 0

        $Count | % {                                                                                                                  # Begins the loop
    
            If ( $Depth -gt 1 )                                                                                                   # If multiple objects
            {   If ( $C -ne $Null ) { $C = $C + 1 } If ( $C -eq $Null ) { $C = 0 } $Index = $ID[$C] ; $Section = $Table[$C] }

            If ( $Depth -eq 1 )                                                                                                    # If a single object
            {   $C = 0 ; $Index = $ID ; $Section = $Table }

            $Object | Add-Member -MemberType NoteProperty -Name "ID:$C" -Value $Index                           # ^ Same core logic used in either case
            $Keys = @( $Section | GM | ? { $_.MemberType -eq "NoteProperty" } | % { $_.Name } )

            ForEach ( $S in $Keys )                                                                             # Prepares the subtable key/value pairs
            {   $SubTable = [ Ordered ]@{ }                                                                                      # Declares empty table
                ForEach ( $K in $Keys )                                                                                                  # Outputs info
                {   $Section.$K | % { $SubTable.Add( "$K" , @{ ID = $_.ID ; Value = $_.Value } ) } } } 

            $Object | Add-Member -MemberType NoteProperty -Name "Section:$C" -Value $SubTable                             # Outputs temporary hashtable
        }

        Return $Object

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Write-Echo # Modifies Write-Output to stylize strings/arrays/tables  ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        [ CmdLetBinding ( ) ] Param (
            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , ParameterSetName = "0" ) ][ Switch ]        $Action ,
            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , ParameterSetName = "1" ) ][ String ]      $Function ,
            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , ParameterSetName = "2" ) ][ Array  ]         $Array ,
            [ Parameter ( Position = 0 , Mandatory = $True , ValueFromPipeline = $True , ParameterSetName = "3" ) ][ PSCustomObject ] $Table ,
            [ Parameter ( Position = 0 , Mandatory = $True , ParameterSetName = "4" ) ][ Switch ] $Free ,
            [ Parameter ( Position = 0 , Mandatory = $True , ParameterSetName = "5" ) ][ Switch ] $Foot ,
            [ Parameter ( Position = 1 , Mandatory = $True , ParameterSetName = "0" ) ][ String ] $Type ,
            [ Parameter ( Position = 2 , Mandatory = $True , ParameterSetName = "0" ) ][ String ] $Info ,
            [ Parameter ( Position = 1 , ParameterSetName = "2" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "3" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "4" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "5" ) ][ Switch ] $Wrap ,
            [ ValidateSet (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) ]
            [ Parameter ( Position = 3 , ParameterSetName = "0" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "1" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "2" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "3" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "4" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "5" ) ][ Alias ( "F" )][ String ] $ForegroundColor ,
            [ ValidateSet (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) ]
            [ Parameter ( Position = 4 , ParameterSetName = "0" ) ]
            [ Parameter ( Position = 3 , ParameterSetName = "1" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "2" ) ]
            [ Parameter ( Position = 3 , ParameterSetName = "3" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "4" ) ]
            [ Parameter ( Position = 1 , ParameterSetName = "5" ) ][ Alias ( "B" )][ String ] $BackgroundColor ,
            [ Parameter ( Position = 5 , ParameterSetName = "0" ) ]
            [ Parameter ( Position = 4 , ParameterSetName = "1" ) ]
            [ Parameter ( Position = 3 , ParameterSetName = "2" ) ]
            [ Parameter ( Position = 4 , ParameterSetName = "3" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "4" ) ]
            [ Parameter ( Position = 2 , ParameterSetName = "5" ) ][ Alias ( "L" )][ String ] $Log )

        Begin                                                                                                                        # Selects textures
        {
            $B  = @{ 0 = 0..1 ; 1 = 1..0 } ; $Z = "  " , "¯-" , "-_" | % { $_ * 54 } ; $S = " // " , " \\ " ; $F = "/¯¯\" , "\__/" 
            $FR = 0..1 | % { ( $F[( $B[$_] )] ) * 13 -join '' } ; $D  = 0..1 | % { $X , $Y = $B[$_][0..1] ; "$( $S[$X] + $FR[$_] + $F[$X] + $S[$Y] )" }
            $L , $R = $S , $S[1..0] ; $LI = 0..1 | % { $L[$_] + $Z[0] + $R[$_] } ; $OP = @( ) ;
        }

        Process                                                                                                                     # Process Selection
        {   
            If (   $Wrap ) { $OP += "  $( "_" * 112 )  " , $D[0] , $D[1] , " //$( "¯" * 110 )\\ " , $LI[1] }                              # Top Wrapper

            If ( $Action )                                                                                                             # Action Wrapper
            {   $T , $I = $Type , $Info                                                                                    # Concat Type/Info Variables
                If ( $T.Length -gt 20 ) { $T = " $( $T.SubString( 0 , 20 ) )...." }                                              # For Left side length
                Else                    { $T = $T | % { "$( " " * ( 25 - $_.Length ) )$_" } } 
                If ( $I.Length -gt 75 ) { $I = $I.SubString( 0 , 75 ) + ".... " }                                               # For Right side length
                Else                    { $I = $I | % { "$_$( " " * ( 80 - $_.Length ) )" } }
                
                $ST , $SI = ( 25 - $T.Length ) , ( 80 - $I.Length ) | % { " " * $_ }                                  # Calculate Type/Info Positioning
                $Sub = "$( $S[1] )$ST$T : $I$SI$( $S[0] )" ; $AT , $AB = 1..2 | % { $S[0] + $Z[$_] + $S[1] }

                $OP += "" , $AT , $Sub , $AB , ""                                                                                     # Output to Array
            }

            If ( $Function )                                                                                                         # Function Wrapper
            {   $FA = $Function ; If ( $FA.Length -gt 58 ) { $FA = "$( $FA.SubString( 0 , 58 ) )..." } 
                "[ $FA ]" | % { $FA = "$_$( "_" * ( 66 - $_.Length ) )" }

                $OP += "  ____ $( " " * 70  ) $( ( "____    "        ) * 4 )____  " , 
                       " //¯¯\\$( "_" * 70  )/$( ( $F[0..1] -join '' ) * 4 )/¯¯\\ " , 
                       " \\__//$( "¯" * 70  )\$( ( $F[1..0] -join '' ) * 4 )\__// " , 
                       "  ¯¯¯\\__$(   $FA )__/$( ( $F[0..1] -join '' ) * 4 )/¯¯¯  " ,
                       "      ¯$( "¯" * 70  )¯$( ( "    ¯¯¯¯"        ) * 4 )      "
            }

            If (  $Array ) { $Array | % { $OP += $_ } }                                                                                 # Array Wrapper

            If (  $Table )                                                                                                          # Hashtable Wrapper
            {   
                $Index = @( ) ; $Section = @( ) ; $Name = $Null ; $Item = $Null ; $C = $Null                         # Open Arrays, & Nullify Variables
                $ID = $Table | GM | ? { $_.MemberType -eq "NoteProperty" } 
                $ID | ? { $_.Name -eq "Class" } | % { $Title = $Table.$( $_.Name ) }                                                    # Title Wrapper

                $Title = $Title.Replace( ' ' , '-' ) | % { "[ $_ ]" }
                If ( $Title.Length -gt 103 ) { $Title = "$( $Title.Substring( 0 , 103 ) ) ... " }

                $TT = 108 - $Title.Length ; $TX = $TT % 4 ; $TY = ( $TT - $TX ) / 4 ; $TL , $TR = "_¯" , "¯_" | % { $_ * $TY }
                $T = ( $Title | % { "$_" , "$_-" , "$_ " , " $_ -" } )[ $TX ] ; $Title = $S[0] + $TL + $T + $TR + $S[1] ; 
                $OP += $Title , $LI[1]                                                                                                 # Title -> Array
                
                $ID | ? { $_.Name -like      "*ID:*" } | % { $Index   += $Table.$( $_.Name ) }                                            # ID Selector
                $ID | ? { $_.Name -like "*Section:*" } | % { $Section += $Table.$( $_.Name ) }                                       # Section Selector

                $Count = $Index.Count - 1
                $Total = 0                                                                                              # Starts the count ( Critical )

                If ( $Count -gt 0 ) { $Count = 0..$Count }

                $Count | % {

                    If ( $Index.Count -gt 1 )                                                                                             # If Multiple
                    {   
                        If   ( $C -ne $Null ) { $C = $C + 1 }                                                                        # Starts the index
                        If ( ( $C -eq $Null ) -and ( $Name -eq $Null ) ) { $C = 0 }
                        $Name = $Index[$C] ; $Item = $Section[$C]
                    }

                    If ( $Index.Count -eq 1 ) { $Name = [ String ]$Index ; $Item = $Section }                                               # If Single
                    If ( $Name.Length -gt 93 ) { $Name = "$( $Name.Substring( 0 , 93 ) ) ... " }

                    $U = 98 - $Name.Length ; $V = $Total % 2 ; $W = ( 1 - $V ) ; $SHeader = "_" , "¯" | % { "$( $L[$V] + ( "$_" * 108 ) + $R[$V] )" }
                    $SLine = $L[$W] + ( "-" * 10 ) + $Name + ( "-" * $U ) + $R[$W] ; $OP += $SHeader[0] , $SLine , $SHeader[1] ; $Total = $Total + 3

                    $Keys = @( $Item.Keys )

                    ForEach ( $IX in ( 0..( $Item.Keys.Count - 1 ) ) )                                                              # Process Key Pairs
                    {
                        $Item."Item:$IX" | % { $Key = $_.ID ; $Value = $_.Value } ; $Y = $Total % 2

                        If (   $Key.Length -gt 20 ) {   $Key = $Key.SubString( 0 , 20 ) + " ... " } 
                        Else                        {   $Key = $Key | % { "$( " " * ( 25 - $_.Length ) )$_" } }
                        If ( $Value.Length -gt 75 ) { $Value = $Value.SubString( 0 , 75 ) + " ... " } 
                        Else                        { $Value = $Value | % { "$_$( " " * ( 80 - $_.Length ) )" } }

                        $OP += "$( $L[$Y] + $Key ) : $( $Value + $R[$Y] )" ; $Total ++
                    }
                }
            }

            If ( $Free )
            {
                $PI = "($( [ Char ] 960 ))" ; $DA = ( "m" , "d" , "Y" | % { Get-Date -UFormat "%$_" } | % { "$( $_.ToCharArray() )" } ) -join ' / '
                $A = " //¯" , " \\" , " //" , " \\_" ; $E = "[=]" , "\_/" , "| |" ; $BL = -Join $E[0,1,0] ; $SX = ( "  *   " * 6 ) , "$( "     *" * 5 )      "
                $M1 = 0..120 | % { "¯" * $_ } ; $M2 = 0..120 | % { "_" * $_ } ; $M3 = 0..120 | % { " " * $_ } ; $FL = " // /¯¯\\   " , " \\ \__//   "
                $RL = "   //¯¯\ \\ " , "   \\__/ // " ; $X = "$($A[1]+$SX[1])]$($M2[48])_// " , "$($A[2]+$SX[0])]$($M1[48])¯\\ " ; 

                $STR  = "Beginning the fight against Technological Tyranny and Cyber Criminal Activities" , "Dynamically Engineered Digital Security" , 
                "Application Development - Virtualization" , "Network & Hardware Magistration" ,   "What America Once Stood For" , 
                "$Pi A Heightened Sense Of Security $Pi" , "HYBRID" , "BY" , "SECURE-DIGITS-PLUS-LLC" , "MICHAEL C COOK SR"

                $STR  = @( 0..5 | % { $STR[$_] } | % { "[ $_ ]" } ; 6..9 | % { $STR[$_] } | % { "$( $_.ToCharArray() )" } ) ; 
                $Sig = $DA + '  |  ' + $STR[9].Replace( "  " , " " ) ; $Out = @( )

                If ( !$Wrap ) { $OP += "  $($M2[112])  " , $D[0] , $D[1] , "$( $FL[0] )$( ( "¯¯¯¯    " ) * 11 )¯¯¯¯$( $RL[0] )" }
                If (  $Wrap ) { $OP += "$( $FL[0] ) $( $M3[90] ) $( $RL[0] )" }

                # Utter Insanity [ I would never recommend going this far with this... but I did it to make a point ]
                # ----- --------   -       ----- ---------                                             ---- - -----

                $Out += 
                "     $( $STR[0] )    " , 
                "  $( $M2[88] )  " , 
                "$($A[0]+$M1[35])]$($M1[48])¯\\ " , 
                $X[0] , 
                $X[1] , 
                "$($A[1]+$SX[1])]___$($STR[1])___// " , 
                $X[1] , 
                $X[0] , 
                $X[1] ,
                "$($A[1]+$SX[1])]__$( $STR[2])___// " , 
                $X[1] , 
                $X[0] , 
                $X[1] , 
                "$($A[1]+$SX[1])]_______$($STR[3])_______// " , 
                " //  $($STR[4])   ]$($M1[48] )¯\\ " , 
                "$($A[3]+$M2[35])]$($M2[48])_// " , 
                "$($A[0]+$M1[85])\\ " , 
                "$($A[3]+$M2[32]+$BL+$E[1]+$BL+$M2[32])// " , 
                "$($A[0]+$M1[32]+$E[2]+$M3[15]+$E[2]+$M1[32])\\ " , 
                "$($A[3]+$M2[32]+$E[0])  $($STR[6])  $($E[0]+$M2[32])// " , 
                "$($A[0]+$M1[32]+$E[2])  $($M1[11])  $($E[2]+$M1[32])\\ " ,
                "$($A[3]+$M2[17]+$BL*2+$M3[6]+$STR[7]+$M3[6]+$BL*2+$M2[16])_// " , 
                "$($A[0]+$M1[17]+$E[2]+$M1[15]+$M3[6]+$M1[3]+$M3[6]+$M1[15]+$E[2]+$M1[16])¯\\ " ,
                "$($A[3]+$M2[17]+$E[0]) $($STR[8]) $($E[0]+$M2[16])_// " , 
                "$($A[0]+$M1[17]+$E[1]) $($M1[43]) $($E[1]+$M1[16])¯\\ " ,
                "$($A[3]+$M2[10]+$BL*3+$E[0])\__/$($E[0]+$BL*3+$M2[10])_// " , 
                "$($A[0]+$M1[10]+$E[0]+$M1[58]+$E[0]+$M1[10])¯\\ " ,
                "$($A[3]+$M2[10]+$E[0])  $SIG  $($E[0]+$M2[10])_// " , 
                "  $($M1[15])  $($M1[19])     $($M1[30])  $($M1[15])  " , 
                " $($M3[24]+$STR[5]+$M3[24]) "

                $C = 1
                $Out | % { $Y = $C % 2 ; $OP += "$( $FL[$Y] )$_$( $RL[$Y] )" ; $C++ }

                If (  $Wrap ) { $OP += "$( $FL[1] ) $($M3[28]+$M2[34]+$M3[28]) $( $RL[1] )" }
                If ( !$Wrap ) { $OP += "$( $FL[1] )$( ( "____    " ) * 11 )____$( $RL[1] )" , $D[0] , $D[1] , "  $( $M1[112] )  " }
            }

            If ( $Foot )
            {
                $FX = $F[0,1,0,1,0] , $F[1,0,1,0,1] , $F[0,1,0,1] , $F[1,0,1,0] , $F[1,0,1] , $F[0,1,0]                      # Block Selection / Concat
                $F1 , $F2 , $F3 , $F4 , $F5 , $F6  = $FX | % { $_ -join '' } ; $F7 = ( ( $F[1,0] ) * 13 + $F[1] ) -join ''

                $ST = "Secure Digits Plus LLC" , "Hybrid | Desired State Controller" , "Dynamically Engineered Digital Security" ,         # String Dex
                "Application Development" , "Virtualization" , "Network and Hardware Magistration" , "https://www.securedigitsplus.com" ,
                "Server-Client" , "Seedling-Spawning Script" , "You've Just deployed a heightened sense of security"

                $Focus = "$( "-="* 7 | % { "$_-[ $( $ST[2] ) ]-=$_" } )"
                $Title , $Strength , $Domain = $ST[0,1] , $ST[3,4,5] , $ST[6,7,8] | % { $_ -join ' | ' } 

                $Out = @( "$F1\    $( "_" * 58 )    /$F1" , "$F2/    $( $Title )    \$F2" , "$F3/¯¯¯     $( "¯" * 58 )     ¯¯¯\$F4" ,     # Output Prep
                "$F5/¯¯¯ $( $Focus  ) ¯¯¯\$F5"  , "$F6\    $( "¯" * 15 )$( " " * 43 )$( "¯" * 16 )    /$F6" , 
                "$F5/   $( $Strength )   \$F5"  , "$F6\   $( "¯" * 76  )   /$F6" , "$F5/   $(   $Domain )    \$F5" , 
                "$F6\___$( "¯" * 75  ) ___/$F6" , "$F4\___$( " " * 8 )$( $ST[9] )$( " " * 9 )___/$F3" , 
                "$F1\___$( ( ( " " * 4 ) + ( "_" * 4 ) ) * 7 )    ___/$F1" , "$F7" )

                If ( !$Wrap ) { $OP += "  $( "_" * 112 )  " }                                                                          # Send to Output

                $C = 0
                $Out | % { $Y = $C % 2 ; $OP += "$( $L[$Y] )$_$( $R[$Y] )" ; $C ++ }

                If ( !$Wrap ) { $OP += "  $( "¯" * 112 )  " }
            }

            If ( $Wrap ) 
            { 
                If ( ( $OP.Count | Select -Last 1 ) % 2 -ne 0 ) { $OP += $LI[0] } 
                $OP += " \\$( "_" * 110 )// " , $D[0] , $D[1] , "  $( "¯" * 112 )  " 
            }
        }

        End  
        {             
            If ( (  $ForegroundColor ) -and (  $BackgroundColor ) ) { $OP | % { Write-Host -F $ForegroundColor -B $BackgroundColor $_ } }
            If ( (  $BackgroundColor ) -and ( !$ForegroundColor ) ) { $OP | % { Write-Host -B $BackgroundColor $_ } }
            If ( (  $ForegroundColor ) -and ( !$BackgroundColor ) ) { $OP | % { Write-Host -F $ForegroundColor $_ } }
            If ( ( !$ForegroundColor ) -and ( !$BackgroundColor ) ) { $OP | % { Write-Host $_ } }
            If ( $Log ) 
            {
                $Name = "$( ( "Y" , "m" , "d" | % { Get-Date -UFormat "%$_" } ) -join '' )_$( $MyInvocation.MyCommand.Path ).log"

                If ( Test-Path $Log ) 
                { 
                    If ( Test-Path "$Log\$Name" ) { AC "$Log\$Name" $OP }
                    Else { SC "$Log\$Name" $OP }
                }
            }
        }
    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Convert-XAMLToWindow # Modified, originally by Dr. Tobias Weltner    ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        Param ( [ Parameter ( Mandatory ) ] [ String ] $XAML , [ String [] ] $NE = $Null , [ Switch ] $PassThru )

        @( "Framework" , "Core" | % { "Presentation$_" } ) + "WindowsBase" | % { Add-Type -AssemblyName $_ }
 
        $NR = [ XML.XMLReader ]::Create( [ IO.StringReader ] $XAML ) ; $OP = [ Windows.Markup.XAMLReader ]::Load( $NR )
        
        $NE | % { $OP | Add-Member -MemberType NoteProperty -Name $_ -Value $OP.FindName( $_ ) -Force }
 
        If ( $PassThru ) { $OP } Else { $Null = $GUI.Dispatcher.InvokeAsync({ $OP = $GUI.ShowDialog() ; SV -Name OP -Value $OP -Scope 1 }).Wait() ; $OP }

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Show-WPFWindow # Modified, originally by Dr. Tobias Weltner          ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________//¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
        
        Param ( [ Parameter ( Mandatory ) ] [ Windows.Window ] $GUI )

        $OP = $Null ; $Null = $GUI.Dispatcher.InvokeAsync({ $OP = $GUI.ShowDialog() ; SV -Name OP -Value $OP -Scope 1 }).Wait() ; $OP 

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-NBSVC # Maps service nodes found on a NetBIOS Domain             ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        $ID =  "00" , "01" , "01" , "03" , "06" , "1F" , "20" , "21" , "22" , "23" , "24" , "30" , "31" , "43" , "44" , "45" , "46" , "4C" , "42" , 
        "52" , "87" , "6A" , "BE" , "BF" , "03" , "00" , "1B" , "1C" , "1D" , "1E" , "1C" , "00" , "2B" , "2F" , "33" , "20" | % { "<$_>" }

        $Type = ( "UNIQUE" , "GROUP" )[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,1,1]

        $Service = "Workstation" , "Messenger" , "Master Browser" , "Messenger" , "RAS Server" , "NetDDE" , "File Server" ,  "RAS Client" , 
        "Interchange(MSMail Connector)" , "Store" , "Directory" , "Server" , "Client" , "Control" , "SMS Administrators Remote Control Tool" , 
        "Chat" , "Transfer" , "on Windows NT" , "mccaffee anti-virus" , "on Windows NT" , "MTA" , "IMC" , "Network Monitor Agent" , 
        "Network Monitor Application" , "Messenger" , "Name" , "Master Browser" , "Controllers" , "Master Browser" , "Browser Service Elections" , 
        "IIS" , "IIS" , "Server" , "" , "" , "DCA IrmaLan Gateway Server" 

        0,1,3,4,5,6,7,11,12,24,32 | % { $Service[$_] =                     "$( $Service[$_] ) Service" }
        8,9,10,20,21              | % { $Service[$_] =          "Microsoft Exchange $( $Service[$_] )" }
        32,33,34                  | % { $Service[$_] =                 "Lotus Notes $( $Service[$_] )" }
        11,12                     | % { $Service[$_] =               "Modem Sharing $( $Service[$_] )" }
        13,15,16                  | % { $Service[$_] =          "SMS Clients Remote $( $Service[$_] )" }
        25,26,27                  | % { $Service[$_] =                      "Domain $( $Service[$_] )" }
        17,19                     | % { $Service[$_] = "DEC Pathworks TCPIP service $( $Service[$_] )" }

        $List = @( ) ; ForEach ( $i in 0..35 ) { $List += [ PSCustomObject ]@{ ID = $ID[$i] ; Type = $Type[$i] ; Service = $Service[$i] } } ; Return $List

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-NetworkInfo # Obtains DNS, Subnet, IPV4, NetBIOS                 ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
    
        [ CmdLetBinding () ] Param ( [ Parameter ( Position = 0 , Mandatory = $False ) ] [ Switch ] $NetBIOS )

        $OP = @( )

        If ( !$NetBIOS )
        {
            ForEach ( $i in "DNS Suffix" , "IPv4 Address" , "Subnet Mask" )
            {
                ipconfig /all | ? { $_ -like "*$i*" } | % { $_.Split( ':' )[1].Replace( " " , "" ) } | ? { $_.Length -ne 0 } | % { If ( $_ -notin $OP ) { $OP += $_ } }
                "(Preferred)" | ? { $OP -like "*$_*" } | % { $OP = $OP.Replace( "$_" , "" ) } ; If ( $OP -eq $Null ) { $OP += "<NOT DETECTED>" }
            }
            Return [ PSCustomObject ]@{ DNS = $OP[0] ; IPv4 = $OP[1] ; NetMask = $OP[2] }
        }

        If ( $NetBIOS )
        {
            NBTSTAT -n | ? { $_ -like "*Registered*" } | % { $T = $_[0..18] , $_[19..22] , $_[25..36] | % { $_ -join '' } | % { $_.Replace( ' ' , '' ) }
            Get-NBSVC | ? { $T[1] -eq $_.ID -and $T[2] -eq $_.Type } | % { $OP += [ PSCustomObject ]@{ Name = $T[0] ; ID = $T[1] ; Type = $T[2] ; Service = $_.Service } } }
            Return $OP
        }

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-HostRange # Obtains a range of potential hosts                   ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        $Class = "Network" , "A" , "B" , "C" , "D / MC" , "E / R&D" , "Broadcast" , "Loopback"
        $Range = [ Ordered ]@{ 0 = 0 ; 1 = 1..126 ; 2 = 128..191 ; 3 = 192..223 ; 4 = 224..239 ; 5 = 240..254 ; 6 = 6 ; 7 = 127 }
        Get-NetworkInfo | % { $IP = $_.IPV4.Split( '.' ) ; $SM = $_.NetMask.Split( '.' ) }
            
        $Full   = @( ) ; $Concat = 0 ; $Close  = 0

        ForEach ( $I in 0..3 )
        {
            If ( $Close -eq 0 )
            {
                If ( $SM[$I] -eq 255 ) { $Full += $IP[$I] } If ( $SM[$I] -ne 255 ) { $Concat = 1 }
                If ( $Concat -eq 1 )
                {
                    $NW   = $Full -Join "." ; $Full = $NW
                    If ( $SM[$I] -eq 0 ) { $NW , $Start , $End , $BC = 0 , 1 , 254 , 255 | % { "$Full.$_" } }
                    Else
                    {
                        ForEach ( $J in 1..5 ) 
                        { 
                            If ( $SM[$I] -in $Range[$J] )
                            {
                                $X  = $Range[$J] ; $Y  = $X | Select -First 1  , $X | Select -Last  1 ; $Y += $Y[1] + 1
                                $NW , $Start , $End , $BC = $Y[0..2] | % { "$Full.$_" }
                            }
                        }
                    }
                    $Close = 1
                }
            }
            If ( $Close -eq 1 ) { If ( $I -ne 3 ) { $NW , $BC , $Start , $End | % { "$_.0" } } }
        }
            
        Return [ PSCustomObject ]@{ Class = ForEach ( $k in 1..5 ) { If ( $IP[0] -in $Range[$k] ) { "Class $( $Class[$k] ) Address" } }
        Prefix = $Full ; IPV4  = $IP -Join "." ; NetMask = $SM -Join "." ; Subnet = $NW ; Start = $Start ; End = $End ; Echo = $BC }

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-HostMask # Obtains NetMask Chart, number of hosts and etc.       ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
    
        [ CmdLetBinding () ] Param ( 
        
            [ Parameter ( Position = 0 , Mandatory = $True , ParameterSetName = "0" ) ][ Switch ] $Locate  , 
            [ Parameter ( Position = 0 , Mandatory = $True , ParameterSetName = "1" ) ][ Switch ] $HostMap , 
            [ Parameter ( Position = 0 , Mandatory = $True , ParameterSetName = "2" ) ][ Switch ] $Table   )

            $V  = @( 0..9 | % { "  $_" }  ; 10..99 | % { " $_" } ; 100..255 | % { "$_" } ) | % { "[$_]" } ; $W  = $V.Replace( " " , "¯" ) ; $CT = 0 ;
            $OB = 0..126 ; $Bot = 0..15  | % { "¯" * $_ } ; $Top = 0..15 | % { "_" * $_ } ; $Items = 0..3 ; $GT = $W , $V , $V , $V
            $GX = "Mask" , "Start" , "End" , "Broad" | % { "[$( "¯" * ( 6 - $_.Length ) )$( $_ ):¯" } 
            
            ForEach ( $i in 0..3 ) { $Items[$I] = $GT[$I] | % { $GX[$I] , $_ -join '' } } ; $Subnet , $Start , $End , $Echo = $Items[0..3] ; $OP = @( )

            1 , 2 , 4 , 8 , 16 , 32 , 64 | % { 
                $I = $_ ; $X = 256 / $I ; If ( $I -gt 1 ) { $C = $I..1 } Else { $C = 1 } ; $Y = $C | % { 256 - ( $X ) * $_ } ; If ( $I -gt 1 ) { $C = 0..( $I - 1 ) }
                $C | % { $X * $_ } | % {  If ( $I -eq 1 ) { $OB[$CT] = [ PSCustomObject ]@{ Count = 1 ; Subnet = 0 ; Start = 1 ; End = 254 ; Echo = 255 } }
                    Else { $OB[$CT] = [ PSCustomObject ]@{ Count = "$( $_ / $X + 1 )/$I" ; Subnet = $_ ; Start = $_ + 1 ; End   = $_ + ( $X - 2 ) ; Echo  = $_ + ( $X - 1 ) } }
                    $CT ++
                }
            }

            If (   $Table ) { Return $OB }
            If (  $Locate ) 
            { 
                $Hosts = Get-HostRange ; $PFX = $Hosts.Prefix ; $K = $Hosts | Select Subnet , Start , End , Echo
                $Comp  = $OB | Select @{ Name = "Subnet" ; Expression = { "$PFX.$( $_.Subnet )" } } , @{ Name =  "Start" ; Expression = { "$PFX.$( $_.Start  )" } } , 
                                      @{ Name =    "End" ; Expression = { "$PFX.$( $_.End    )" } } , @{ Name =   "Echo" ; Expression = { "$PFX.$( $_.Echo   )" } }
                $I = 0 ; $Comp | % { If ( $_.Subnet -eq $K.Subnet -and $_.Start -eq $K.Start -and $_.End -eq $K.End -and $_.Echo -eq $K.Echo ) { $Select = $OB[$I] } Else { $I++ } }
                Return $Select
            }

            If ( $HostMap )
            {
                $OB | ? { $_.Count -eq "1" } | % { $Top[14] , "[ 1 _________]" , $Subnet[$_.Subnet] , $Start[$_.Start] , $End[$_.End] , $Echo[ $_.Echo] , $Bot[14] | % { $OP += $_ } }
                ForEach ( $I in 2 , 4 , 8 , 16 , 32 , 64 )
                {
                    $Object = $OB | ? { $_.Count -like  "*/$I*" } ; $OC = $Object.Count - 1 ; $LJ = 0..$OC
                    ForEach ( $I in $LJ )
                    {
                        $Object[$I] | % { $NWQ = $_.Count | % { "[_ $_ $( "_" * ( 9 - $_.Length ) )]" }
                            $LJ[$I] = [ PSCustomObject ]@{ 0 = $Top[14] ; 1 = $NWQ ; 2 = $Subnet[$_.Subnet] ; 3 = $Start[$_.Start] ; 4 = $End[$_.End] ; 5 = $Echo[$_.Echo] ; 6 = $Bot[14] } 
                        }
                    }
        
                    If ( $I -eq $OC )
                    {   
                        $OP += 0..6 | % { $LJ[0..7].$_ -join '' }
                        If ( $I -gt 8 ) { $Loop = ( $Object.Count / 8 ) - 1 ; $L = 0 ; $H = 7 ; 
                        Do { $L += 8 ; $H += 8 ; $OP += 0..6 | % { $LJ[$L..$H].$_ -join '' } ; $Loop -= 1 } Until ( $Loop -eq 0 ) }
                    }
                }
                Return $OP
            }
    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Get-NetworkHosts # Gets actual used network host addresses           ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

        [ CmdLetBinding () ] Param (

            [ ValidateNotNullOrEmpty()][ Parameter ( Position = 0 , ParameterSetName = "0" , HelpMessage = "Return HostIPs" ) ][ Switch ]    $HostIP ,
            [ ValidateNotNullOrEmpty()][ Parameter ( Position = 0 , ParameterSetName = "1" , HelpMessage = "Return HostMAC" ) ][ Switch ]   $HostMAC ,
            [ ValidateNotNullOrEmpty()][ Parameter ( Position = 0 , ParameterSetName = "2" , HelpMessage = "Dynamic/Static" ) ][ Switch ] $LeaseType ,
            [ ValidateNotNullOrEmpty()][ Parameter ( Position = 0 , ParameterSetName = "3" , HelpMessage = "Pulls all data" ) ][ Switch ]       $All )

        $ARP  = arp -a | ? { $_ -like "*$( ( Get-HostRange ).Prefix )*" -and $_ -notlike "*Interface*" }
        $RARP = $( If ( $ARP.Count -gt 1 ) { 0..( $ARP.Count - 1 ) } Else { 0 } )

        ForEach ( $I in $RARP )
        { 
            $Values = $ARP[$I] | % { $_[0..23] , $_[24..40] , $_[41..56] } | % { $_ -join '' } | % { $_.Replace( ' ' , '' ) }
            $RARP[$I] = [ PSCustomObject ]@{ HostIP = $Values[0] ; HostMAC = $Values[1] ; LeaseType = $Values[2] }
        }

        If ( $HostIP ) { Return $RARP.HostIP } ; If ( $HostMAC ) { Return $RARP.HostMAC } If ( $LeaseType ) { Return $RARP.LeaseType } 
        Else { Return $RARP }

    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
    Function Start-PingSweep # Gets actual used network host addresses            ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
    {#\______________________________________________________________________________/¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      

     # modified  version of ( @ 2014-08-30 G.A.F.F. Jakobs )
     # modified Revision of ( @ 2016-01-09 Kory Gill )
     # Already had a working method of extracting the IP address information, the sync is what I needed.

        [ CmdletBinding ( ) ] Param (
            
            [ Parameter ( Mandatory = $True , Position = 0 ) ] [    Int ] $Interval  = 30     ,
                                                               [ Switch ] $RawOutput = $False )

        $Hosts   = @( ) ; $Report  = @{ Success = @( ) ; Failed = @( ) }

        Get-NetworkInfo | % { $NetMask = $_.NetMask ; $IP        = $_.IPv4 ; $Hosts += $IP }
        Get-HostRange   | % { $PFX     = $_.Prefix  ; $Broadcast = $_.Echo }

        Get-NetworkHosts -HostIP | % { $Hosts   += @( $_ ) }
        Get-HostMask     -Locate | % { $HostList = @( $_.Start..$_.End | % { "$PFX.$_" } | ? { $_ -notin $Hosts } ) }

        $List = $HostList | % { [ IPAddress ] $_ } ; $Timeout = 650  ; $Total = $List.Count ; $Range   = 0..( $Total - 1 )

        "ID-Ping*" | % { 
            Get-Event           -SourceIdentifier $_ |     Remove-Event
            Get-EventSubscriber -SourceIdentifier $_ | Unregister-Event 
        }

        ForEach ( $i in $Range )
        {
            [ String ]$Ping = "Ping_$( $List[$I].Address )"

            NV -Name  $Ping -Value ( New-Object System.Net.NetworkInformation.Ping )
            
            $Register = @{ InputObject = GV $Ping -ValueOnly ; EventName = "PingCompleted" ; SourceIdentifier = "ID-$Ping" }
            
            Register-ObjectEvent @Register

            ( GV $Ping -ValueOnly ).SendPingAsync( $_ , $Timeout , $Ping )

            RV $Ping
            
            Try { $Pending = ( Get-Event -SourceIdentifier "ID-Ping*" ).Count }

            Catch [ System.InvalidOperationException ] { $Pending = 0  }

            $Progress = @{ Activity = "Pinging: $( $HostList[$i] )" ; ID = 1 ; Status = "$( $HostList[$i] )" ; PercentComplete = ( $I / $Total ) * 100 }

            Write-Progress @Progress

            $Percent = ( $( $I - $Total ), 0 | Measure -Maximum ).Maximum

            $Progress = @{ Activity = "Echo requests pending" ; ID = 2 ; ParentID = 1 ; Status = $I / $Pending ; PercentComplete = ( $Percent / $Total ) * 100 }

            Sleep -M $Interval

        }
        
        Write-Progress -Activity "All Echo Requests transmitted" -Id 1 -Status 'Waiting' -PercentComplete 100 

        While ( $Pending -lt $Total )
        {
            Wait-Event -SourceIdentifier "ID-Ping*" | Out-Null

            Sleep -M 10

            Try { $Pending = ( Get-Event -SourceIdentifier "ID-Ping*" ).Count }

            Catch [ System.InvalidOperationException ] { $Pending = 0 }

            $Percentage = ( $( $I - $Total ), 0 | Measure -Maximum ).Maximum

            $Progress = @{ Activity = "Echo Sent" ; ID = 2 ; ParentID = 1 ; Status = $I / $Pending ; PercentComplete = ( $Percent / $Total ) * 100 }

            Write-Progress @Progress
        }

        Write-Progress -Completed -ID 2 -ParentID 1 -Activity "Completed"
        Write-Progress -Completed -ID 1 -Activity "Completed"

        $Reply = @( )

        If ( $RawOutput )
        {
            Get-Event -SourceIdentifier "ID-Ping*" | % { 

                If ( $_.SourceEventArgs.Reply.Status -eq "Success" )
                {
                    $Reply += $_.SourceEventArgs.Reply
                }
                Unregister-Event $_.SourceIdentifier
                Remove-Event     $_.SourceIdentifier
            }
        }

        Else
        {
            Get-Event -SourceIdentifier "ID-Ping*" | % {
                
                If ( $_.SourceEventArgs.reply.Status -eq "Success" )
                {
                    $_.SourceEventArgs.Reply | % { 
                    $Pinger = @{ IPAddress    = $_.Address
                                 Bytes        = $_.Buffer.Length
                                 TTL          = $_.Options.TTL
                                 ResponseTime = $_.RoundTripTime }
                    }
                    $Reply += New-Object PSCustomObject -Property $Pinger
                }
                Unregister-Event $_.SourceIdentifier
                Remove-Event     $_.SourceIdentifier
            }
        }

        If ( $Reply.Count -eq 0 )
        {
            Write-Echo -Function "Ping-IPRange : No Echo Responses Received." -F 11 0
        }

        Return $Reply
    }#                                                                            ____    ____    ____    ____    ____    ____    ____    ____    ____  
#//¯¯\\__________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
#\\__//¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
        Write-Echo -Free -F 10 -B 0 ; Sleep 1 # What Free Actually Means         #¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
     #\______________________________________________________________________________//¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯      
     # ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ 
